#include <Windows.h>

#include "GL/LostGL.h"
#include "Audio/Audio.h"

#include "lostImGui.h"

#include "imgui/imgui_impl_glfw.h"
#include "imgui/imgui_impl_opengl3.h"
#include "imgui/imgui_internal.h"

#include "GL/Renderer.h"
#include "DeltaTime.h"

#include <tchar.h>
#include <iostream>
#include <locale>
#include <codecvt>
#include <string>

#ifndef NOMINMAX
#define NOMINMAX
#endif

#ifdef LOST_DEBUG_MODE
#define LOST_FRAME_RATE_HISTORY_ENABLED true
#define LOST_FRAME_RATE_HISTORY_COUNT 500 // Frame count to store
#else
#define LOST_FRAME_RATE_HISTORY_ENABLED false
#define LOST_FRAME_RATE_HISTORY_COUNT 500 // Frame count to store
#endif

namespace ImGui
{
	std::map<std::string, bool*> _IDToggleMap;

	// File: 'ProggyClean.ttf' (41208 bytes)
	// Exported using binary_to_compressed_c.exe -u8 "ProggyClean.ttf" proggy_clean_ttf
	static const unsigned int proggy_clean_ttf_compressed_size = 9583;
	static const unsigned char proggy_clean_ttf_compressed_data[9583] =
	{
		87,188,0,0,0,0,0,0,0,0,160,248,0,4,0,0,55,0,1,0,0,0,12,0,128,0,3,0,64,79,83,47,50,136,235,116,144,0,0,1,72,130,21,44,78,99,109,97,112,2,18,35,117,0,0,3,160,130,19,36,82,99,118,116,
		32,130,23,130,2,33,4,252,130,4,56,2,103,108,121,102,18,175,137,86,0,0,7,4,0,0,146,128,104,101,97,100,215,145,102,211,130,27,32,204,130,3,33,54,104,130,16,39,8,66,1,195,0,0,1,4,130,
		15,59,36,104,109,116,120,138,0,126,128,0,0,1,152,0,0,2,6,108,111,99,97,140,115,176,216,0,0,5,130,30,41,2,4,109,97,120,112,1,174,0,218,130,31,32,40,130,16,44,32,110,97,109,101,37,89,
		187,150,0,0,153,132,130,19,44,158,112,111,115,116,166,172,131,239,0,0,155,36,130,51,44,210,112,114,101,112,105,2,1,18,0,0,4,244,130,47,32,8,132,203,46,1,0,0,60,85,233,213,95,15,60,
		245,0,3,8,0,131,0,34,183,103,119,130,63,43,0,0,189,146,166,215,0,0,254,128,3,128,131,111,130,241,33,2,0,133,0,32,1,130,65,38,192,254,64,0,0,3,128,131,16,130,5,32,1,131,7,138,3,33,2,
		0,130,17,36,1,1,0,144,0,130,121,130,23,38,2,0,8,0,64,0,10,130,9,32,118,130,9,130,6,32,0,130,59,33,1,144,131,200,35,2,188,2,138,130,16,32,143,133,7,37,1,197,0,50,2,0,131,0,33,4,9,131,
		5,145,3,43,65,108,116,115,0,64,0,0,32,172,8,0,131,0,35,5,0,1,128,131,77,131,3,33,3,128,191,1,33,1,128,130,184,35,0,0,128,0,130,3,131,11,32,1,130,7,33,0,128,131,1,32,1,136,9,32,0,132,
		15,135,5,32,1,131,13,135,27,144,35,32,1,149,25,131,21,32,0,130,0,32,128,132,103,130,35,132,39,32,0,136,45,136,97,133,17,130,5,33,0,0,136,19,34,0,128,1,133,13,133,5,32,128,130,15,132,
		131,32,3,130,5,32,3,132,27,144,71,32,0,133,27,130,29,130,31,136,29,131,63,131,3,65,63,5,132,5,132,205,130,9,33,0,0,131,9,137,119,32,3,132,19,138,243,130,55,32,1,132,35,135,19,131,201,
		136,11,132,143,137,13,130,41,32,0,131,3,144,35,33,128,0,135,1,131,223,131,3,141,17,134,13,136,63,134,15,136,53,143,15,130,96,33,0,3,131,4,130,3,34,28,0,1,130,5,34,0,0,76,130,17,131,
		9,36,28,0,4,0,48,130,17,46,8,0,8,0,2,0,0,0,127,0,255,32,172,255,255,130,9,34,0,0,129,132,9,130,102,33,223,213,134,53,132,22,33,1,6,132,6,64,4,215,32,129,165,216,39,177,0,1,141,184,
		1,255,133,134,45,33,198,0,193,1,8,190,244,1,28,1,158,2,20,2,136,2,252,3,20,3,88,3,156,3,222,4,20,4,50,4,80,4,98,4,162,5,22,5,102,5,188,6,18,6,116,6,214,7,56,7,126,7,236,8,78,8,108,
		8,150,8,208,9,16,9,74,9,136,10,22,10,128,11,4,11,86,11,200,12,46,12,130,12,234,13,94,13,164,13,234,14,80,14,150,15,40,15,176,16,18,16,116,16,224,17,82,17,182,18,4,18,110,18,196,19,
		76,19,172,19,246,20,88,20,174,20,234,21,64,21,128,21,166,21,184,22,18,22,126,22,198,23,52,23,142,23,224,24,86,24,186,24,238,25,54,25,150,25,212,26,72,26,156,26,240,27,92,27,200,28,
		4,28,76,28,150,28,234,29,42,29,146,29,210,30,64,30,142,30,224,31,36,31,118,31,166,31,166,32,16,130,1,52,46,32,138,32,178,32,200,33,20,33,116,33,152,33,238,34,98,34,134,35,12,130,1,
		33,128,35,131,1,60,152,35,176,35,216,36,0,36,74,36,104,36,144,36,174,37,6,37,96,37,130,37,248,37,248,38,88,38,170,130,1,8,190,216,39,64,39,154,40,10,40,104,40,168,41,14,41,32,41,184,
		41,248,42,54,42,96,42,96,43,2,43,42,43,94,43,172,43,230,44,32,44,52,44,154,45,40,45,92,45,120,45,170,45,232,46,38,46,166,47,38,47,182,47,244,48,94,48,200,49,62,49,180,50,30,50,158,
		51,30,51,130,51,238,52,92,52,206,53,58,53,134,53,212,54,38,54,114,54,230,55,118,55,216,56,58,56,166,57,18,57,116,57,174,58,46,58,154,59,6,59,124,59,232,60,58,60,150,61,34,61,134,61,
		236,62,86,62,198,63,42,63,154,64,18,64,106,64,208,65,54,65,162,66,8,66,64,66,122,66,184,66,240,67,98,67,204,68,42,68,138,68,238,69,88,69,182,69,226,70,84,70,180,71,20,71,122,71,218,
		72,84,72,198,73,64,0,36,70,21,8,8,77,3,0,7,0,11,0,15,0,19,0,23,0,27,0,31,0,35,0,39,0,43,0,47,0,51,0,55,0,59,0,63,0,67,0,71,0,75,0,79,0,83,0,87,0,91,0,95,0,99,0,103,0,107,0,111,0,115,
		0,119,0,123,0,127,0,131,0,135,0,139,0,143,0,0,17,53,51,21,49,150,3,32,5,130,23,32,33,130,3,211,7,151,115,32,128,133,0,37,252,128,128,2,128,128,190,5,133,74,32,4,133,6,206,5,42,0,7,
		1,128,0,0,2,0,4,0,0,65,139,13,37,0,1,53,51,21,7,146,3,32,3,130,19,32,1,141,133,32,3,141,14,131,13,38,255,0,128,128,0,6,1,130,84,35,2,128,4,128,140,91,132,89,32,51,65,143,6,139,7,33,
		1,0,130,57,32,254,130,3,32,128,132,4,32,4,131,14,138,89,35,0,0,24,0,130,0,33,3,128,144,171,66,55,33,148,115,65,187,19,32,5,130,151,143,155,163,39,32,1,136,182,32,253,134,178,132,7,
		132,200,145,17,32,3,65,48,17,165,17,39,0,0,21,0,128,255,128,3,65,175,17,65,3,27,132,253,131,217,139,201,155,233,155,27,131,67,131,31,130,241,33,255,0,131,181,137,232,132,15,132,4,138,
		247,34,255,0,128,179,238,32,0,130,0,32,20,65,239,48,33,0,19,67,235,10,32,51,65,203,14,65,215,11,32,7,154,27,135,39,32,33,130,35,33,128,128,130,231,32,253,132,231,32,128,132,232,34,
		128,128,254,133,13,136,8,32,253,65,186,5,130,36,130,42,176,234,133,231,34,128,0,0,66,215,44,33,0,1,68,235,6,68,211,19,32,49,68,239,14,139,207,139,47,66,13,7,32,51,130,47,33,1,0,130,
		207,35,128,128,1,0,131,222,131,5,130,212,130,6,131,212,32,0,130,10,133,220,130,233,130,226,32,254,133,255,178,233,39,3,1,128,3,0,2,0,4,68,15,7,68,99,12,130,89,130,104,33,128,4,133,
		93,130,10,38,0,0,11,1,0,255,0,68,63,16,70,39,9,66,215,8,32,7,68,77,6,68,175,14,32,29,68,195,6,132,7,35,2,0,128,255,131,91,132,4,65,178,5,141,111,67,129,23,165,135,140,107,142,135,33,
		21,5,69,71,6,131,7,33,1,0,140,104,132,142,130,4,137,247,140,30,68,255,12,39,11,0,128,0,128,3,0,3,69,171,15,67,251,7,65,15,8,66,249,11,65,229,7,67,211,7,66,13,7,35,1,128,128,254,133,
		93,32,254,131,145,132,4,132,18,32,2,151,128,130,23,34,0,0,9,154,131,65,207,8,68,107,15,68,51,7,32,7,70,59,7,135,121,130,82,32,128,151,111,41,0,0,4,0,128,255,0,1,128,1,137,239,33,0,
		37,70,145,10,65,77,10,65,212,14,37,0,0,0,5,0,128,66,109,5,70,123,10,33,0,19,72,33,18,133,237,70,209,11,33,0,2,130,113,137,119,136,115,33,1,0,133,43,130,5,34,0,0,10,69,135,6,70,219,
		13,66,155,7,65,9,12,66,157,11,66,9,11,32,7,130,141,132,252,66,151,9,137,9,66,15,30,36,0,20,0,128,0,130,218,71,11,42,68,51,8,65,141,7,73,19,15,69,47,23,143,39,66,81,7,32,1,66,55,6,34,
		1,128,128,68,25,5,69,32,6,137,6,136,25,32,254,131,42,32,3,66,88,26,148,26,32,0,130,0,32,14,164,231,70,225,12,66,233,7,67,133,19,71,203,15,130,161,32,255,130,155,32,254,139,127,134,
		12,164,174,33,0,15,164,159,33,59,0,65,125,20,66,25,7,32,5,68,191,6,66,29,7,144,165,65,105,9,35,128,128,255,0,137,2,133,182,164,169,33,128,128,197,171,130,155,68,235,7,32,21,70,77,19,
		66,21,10,68,97,8,66,30,5,66,4,43,34,0,17,0,71,19,41,65,253,20,71,25,23,65,91,15,65,115,7,34,2,128,128,66,9,8,130,169,33,1,0,66,212,13,132,28,72,201,43,35,0,0,0,18,66,27,38,76,231,5,
		68,157,20,135,157,32,7,68,185,13,65,129,28,66,20,5,32,253,66,210,11,65,128,49,133,61,32,0,65,135,6,74,111,37,72,149,12,66,203,19,65,147,19,68,93,7,68,85,8,76,4,5,33,255,0,133,129,34,
		254,0,128,68,69,8,181,197,34,0,0,12,65,135,32,65,123,20,69,183,27,133,156,66,50,5,72,87,10,67,137,32,33,0,19,160,139,78,251,13,68,55,20,67,119,19,65,91,36,69,177,15,32,254,143,16,65,
		98,53,32,128,130,0,32,0,66,43,54,70,141,23,66,23,15,131,39,69,47,11,131,15,70,129,19,74,161,9,36,128,255,0,128,254,130,153,65,148,32,67,41,9,34,0,0,4,79,15,5,73,99,10,71,203,8,32,3,
		72,123,6,72,43,8,32,2,133,56,131,99,130,9,34,0,0,6,72,175,5,73,159,14,144,63,135,197,132,189,133,66,33,255,0,73,6,7,70,137,12,35,0,0,0,10,130,3,73,243,25,67,113,12,65,73,7,69,161,7,
		138,7,37,21,2,0,128,128,254,134,3,73,116,27,33,128,128,130,111,39,12,0,128,1,0,3,128,2,72,219,21,35,43,0,47,0,67,47,20,130,111,33,21,1,68,167,13,81,147,8,133,230,32,128,77,73,6,32,
		128,131,142,134,18,130,6,32,255,75,18,12,131,243,37,128,0,128,3,128,3,74,231,21,135,123,32,29,134,107,135,7,32,21,74,117,7,135,7,134,96,135,246,74,103,23,132,242,33,0,10,67,151,28,
		67,133,20,66,141,11,131,11,32,3,77,71,6,32,128,130,113,32,1,81,4,6,134,218,66,130,24,131,31,34,0,26,0,130,0,77,255,44,83,15,11,148,155,68,13,7,32,49,78,231,18,79,7,11,73,243,11,32,
		33,65,187,10,130,63,65,87,8,73,239,19,35,0,128,1,0,131,226,32,252,65,100,6,32,128,139,8,33,1,0,130,21,32,253,72,155,44,73,255,20,32,128,71,67,8,81,243,39,67,15,20,74,191,23,68,121,
		27,32,1,66,150,6,32,254,79,19,11,131,214,32,128,130,215,37,2,0,128,253,0,128,136,5,65,220,24,147,212,130,210,33,0,24,72,219,42,84,255,13,67,119,16,69,245,19,72,225,19,65,3,15,69,93,
		19,131,55,132,178,71,115,14,81,228,6,142,245,33,253,0,132,43,172,252,65,16,11,75,219,8,65,219,31,66,223,24,75,223,10,33,29,1,80,243,10,66,175,8,131,110,134,203,133,172,130,16,70,30,
		7,164,183,130,163,32,20,65,171,48,65,163,36,65,143,23,65,151,19,65,147,13,65,134,17,133,17,130,216,67,114,5,164,217,65,137,12,72,147,48,79,71,19,74,169,22,80,251,8,65,173,7,66,157,
		15,74,173,15,32,254,65,170,8,71,186,45,72,131,6,77,143,40,187,195,152,179,65,123,38,68,215,57,68,179,15,65,85,7,69,187,14,32,21,66,95,15,67,19,25,32,1,83,223,6,32,2,76,240,7,77,166,
		43,65,8,5,130,206,32,0,67,39,54,143,167,66,255,19,82,193,11,151,47,85,171,5,67,27,17,132,160,69,172,11,69,184,56,66,95,6,33,12,1,130,237,32,2,68,179,27,68,175,16,80,135,15,72,55,7,
		71,87,12,73,3,12,132,12,66,75,32,76,215,5,169,139,147,135,148,139,81,12,12,81,185,36,75,251,7,65,23,27,76,215,9,87,165,12,65,209,15,72,157,7,65,245,31,32,128,71,128,6,32,1,82,125,5,
		34,0,128,254,131,169,32,254,131,187,71,180,9,132,27,32,2,88,129,44,32,0,78,47,40,65,79,23,79,171,14,32,21,71,87,8,72,15,14,65,224,33,130,139,74,27,62,93,23,7,68,31,7,75,27,7,139,15,
		74,3,7,74,23,27,65,165,11,65,177,15,67,123,5,32,1,130,221,32,252,71,96,5,74,12,12,133,244,130,25,34,1,0,128,130,2,139,8,93,26,8,65,9,32,65,57,14,140,14,32,0,73,79,67,68,119,11,135,
		11,32,51,90,75,14,139,247,65,43,7,131,19,139,11,69,159,11,65,247,6,36,1,128,128,253,0,90,71,9,33,1,0,132,14,32,128,89,93,14,69,133,6,130,44,131,30,131,6,65,20,56,33,0,16,72,179,40,
		75,47,12,65,215,19,74,95,19,65,43,11,131,168,67,110,5,75,23,17,69,106,6,75,65,5,71,204,43,32,0,80,75,47,71,203,15,159,181,68,91,11,67,197,7,73,101,13,68,85,6,33,128,128,130,214,130,
		25,32,254,74,236,48,130,194,37,0,18,0,128,255,128,77,215,40,65,139,64,32,51,80,159,10,65,147,39,130,219,84,212,43,130,46,75,19,97,74,33,11,65,201,23,65,173,31,33,1,0,79,133,6,66,150,
		5,67,75,48,85,187,6,70,207,37,32,71,87,221,13,73,163,14,80,167,15,132,15,83,193,19,82,209,8,78,99,9,72,190,11,77,110,49,89,63,5,80,91,35,99,63,32,70,235,23,81,99,10,69,148,10,65,110,
		36,32,0,65,99,47,95,219,11,68,171,51,66,87,7,72,57,7,74,45,17,143,17,65,114,50,33,14,0,65,111,40,159,195,98,135,15,35,7,53,51,21,100,78,9,95,146,16,32,254,82,114,6,32,128,67,208,37,
		130,166,99,79,58,32,17,96,99,14,72,31,19,72,87,31,82,155,7,67,47,14,32,21,131,75,134,231,72,51,17,72,78,8,133,8,80,133,6,33,253,128,88,37,9,66,124,36,72,65,12,134,12,71,55,43,66,139,
		27,85,135,10,91,33,12,65,35,11,66,131,11,71,32,8,90,127,6,130,244,71,76,11,168,207,33,0,12,66,123,32,32,0,65,183,15,68,135,11,66,111,7,67,235,11,66,111,15,32,254,97,66,12,160,154,67,
		227,52,80,33,15,87,249,15,93,45,31,75,111,12,93,45,11,77,99,9,160,184,81,31,12,32,15,98,135,30,104,175,7,77,249,36,69,73,15,78,5,12,32,254,66,151,19,34,128,128,4,87,32,12,149,35,133,
		21,96,151,31,32,19,72,35,5,98,173,15,143,15,32,21,143,99,158,129,33,0,0,65,35,52,65,11,15,147,15,98,75,11,33,1,0,143,151,132,15,32,254,99,200,37,132,43,130,4,39,0,10,0,128,1,128,3,
		0,104,151,14,97,187,20,69,131,15,67,195,11,87,227,7,33,128,128,132,128,33,254,0,68,131,9,65,46,26,42,0,0,0,7,0,0,255,128,3,128,0,88,223,15,33,0,21,89,61,22,66,209,12,65,2,12,37,0,2,
		1,0,3,128,101,83,8,36,0,1,53,51,29,130,3,34,21,1,0,66,53,8,32,0,68,215,6,100,55,25,107,111,9,66,193,11,72,167,8,73,143,31,139,31,33,1,0,131,158,32,254,132,5,33,253,128,65,16,9,133,
		17,89,130,25,141,212,33,0,0,93,39,8,90,131,25,93,39,14,66,217,6,106,179,8,159,181,71,125,15,139,47,138,141,87,11,14,76,23,14,65,231,26,140,209,66,122,8,81,179,5,101,195,26,32,47,74,
		75,13,69,159,11,83,235,11,67,21,16,136,167,131,106,130,165,130,15,32,128,101,90,24,134,142,32,0,65,103,51,108,23,11,101,231,15,75,173,23,74,237,23,66,15,6,66,46,17,66,58,17,65,105,
		49,66,247,55,71,179,12,70,139,15,86,229,7,84,167,15,32,1,95,72,12,89,49,6,33,128,128,65,136,38,66,30,9,32,0,100,239,7,66,247,29,70,105,20,65,141,19,69,81,15,130,144,32,128,83,41,5,
		32,255,131,177,68,185,5,133,126,65,97,37,32,0,130,0,33,21,0,130,55,66,195,28,67,155,13,34,79,0,83,66,213,13,73,241,19,66,59,19,65,125,11,135,201,66,249,16,32,128,66,44,11,66,56,17,
		68,143,8,68,124,38,67,183,12,96,211,9,65,143,29,112,171,5,32,0,68,131,63,34,33,53,51,71,121,11,32,254,98,251,16,32,253,74,231,10,65,175,37,133,206,37,0,0,8,1,0,0,107,123,11,113,115,
		9,33,0,1,130,117,131,3,73,103,7,66,51,18,66,44,5,133,75,70,88,5,32,254,65,39,12,68,80,9,34,12,0,128,107,179,28,68,223,6,155,111,86,147,15,32,2,131,82,141,110,33,254,0,130,15,32,4,103,
		184,15,141,35,87,176,5,83,11,5,71,235,23,114,107,11,65,189,16,70,33,15,86,153,31,135,126,86,145,30,65,183,41,32,0,130,0,32,10,65,183,24,34,35,0,39,67,85,9,65,179,15,143,15,33,1,0,65,
		28,17,157,136,130,123,32,20,130,3,32,0,97,135,24,115,167,19,80,71,12,32,51,110,163,14,78,35,19,131,19,155,23,77,229,8,78,9,17,151,17,67,231,46,94,135,8,73,31,31,93,215,56,82,171,25,
		72,77,8,162,179,169,167,99,131,11,69,85,19,66,215,15,76,129,13,68,115,22,72,79,35,67,113,5,34,0,0,19,70,31,46,65,89,52,73,223,15,85,199,33,95,33,8,132,203,73,29,32,67,48,16,177,215,
		101,13,15,65,141,43,69,141,15,75,89,5,70,0,11,70,235,21,178,215,36,10,0,128,0,0,71,207,24,33,0,19,100,67,6,80,215,11,66,67,7,80,43,12,71,106,7,80,192,5,65,63,5,66,217,26,33,0,13,156,
		119,68,95,5,72,233,12,134,129,85,81,11,76,165,20,65,43,8,73,136,8,75,10,31,38,128,128,0,0,0,13,1,130,4,32,3,106,235,29,114,179,12,66,131,23,32,7,77,133,6,67,89,12,131,139,116,60,9,
		89,15,37,32,0,74,15,7,103,11,22,65,35,5,33,55,0,93,81,28,67,239,23,78,85,5,107,93,14,66,84,17,65,193,26,74,183,10,66,67,34,143,135,79,91,15,32,7,117,111,8,75,56,9,84,212,9,154,134,
		32,0,130,0,32,18,130,3,70,171,41,83,7,16,70,131,19,84,191,15,84,175,19,84,167,30,84,158,12,154,193,68,107,15,33,0,0,65,79,42,65,71,7,73,55,7,118,191,16,83,180,9,32,255,76,166,9,154,
		141,32,0,130,0,69,195,52,65,225,15,151,15,75,215,31,80,56,10,68,240,17,100,32,9,70,147,39,65,93,12,71,71,41,92,85,15,84,135,23,78,35,15,110,27,10,84,125,8,107,115,29,136,160,38,0,0,
		14,0,128,255,0,82,155,24,67,239,8,119,255,11,69,131,11,77,29,6,112,31,8,134,27,105,203,8,32,2,75,51,11,75,195,12,74,13,29,136,161,37,128,0,0,0,11,1,130,163,82,115,8,125,191,17,69,35,
		12,74,137,15,143,15,32,1,65,157,12,136,12,161,142,65,43,40,65,199,6,65,19,24,102,185,11,76,123,11,99,6,12,135,12,32,254,130,8,161,155,101,23,9,39,8,0,0,1,128,3,128,2,78,63,17,72,245,
		12,67,41,11,90,167,9,32,128,97,49,9,32,128,109,51,14,132,97,81,191,8,130,97,125,99,12,121,35,9,127,75,15,71,79,12,81,151,23,87,97,7,70,223,15,80,245,16,105,97,15,32,254,113,17,6,32,
		128,130,8,105,105,8,76,122,18,65,243,21,74,63,7,38,4,1,0,255,0,2,0,119,247,28,133,65,32,255,141,91,35,0,0,0,16,67,63,36,34,59,0,63,77,59,9,119,147,11,143,241,66,173,15,66,31,11,67,
		75,8,81,74,16,32,128,131,255,87,181,42,127,43,5,34,255,128,2,120,235,11,37,19,0,23,0,0,37,109,191,14,118,219,7,127,43,14,65,79,14,35,0,0,0,3,73,91,5,130,5,38,3,0,7,0,11,0,0,70,205,
		11,88,221,12,32,0,73,135,7,87,15,22,73,135,10,79,153,15,97,71,19,65,49,11,32,1,131,104,121,235,11,80,65,11,142,179,144,14,81,123,46,32,1,88,217,5,112,5,8,65,201,15,83,29,15,122,147,
		11,135,179,142,175,143,185,67,247,39,66,199,7,35,5,0,128,3,69,203,15,123,163,12,67,127,7,130,119,71,153,10,141,102,70,175,8,32,128,121,235,30,136,89,100,191,11,116,195,11,111,235,15,
		72,39,7,32,2,97,43,5,132,5,94,67,8,131,8,125,253,10,32,3,65,158,16,146,16,130,170,40,0,21,0,128,0,0,3,128,5,88,219,15,24,64,159,32,135,141,65,167,15,68,163,10,97,73,49,32,255,82,58,
		7,93,80,8,97,81,16,24,67,87,52,34,0,0,5,130,231,33,128,2,80,51,13,65,129,8,113,61,6,132,175,65,219,5,130,136,77,152,17,32,0,95,131,61,70,215,6,33,21,51,90,53,10,78,97,23,105,77,31,
		65,117,7,139,75,24,68,195,9,24,64,22,9,33,0,128,130,11,33,128,128,66,25,5,121,38,5,134,5,134,45,66,40,36,66,59,18,34,128,0,0,66,59,81,135,245,123,103,19,120,159,19,77,175,12,33,255,
		0,87,29,10,94,70,21,66,59,54,39,3,1,128,3,0,2,128,4,24,65,7,15,66,47,7,72,98,12,37,0,0,0,3,1,0,24,65,55,21,131,195,32,1,67,178,6,33,4,0,77,141,8,32,6,131,47,74,67,16,24,69,3,20,24,
		65,251,7,133,234,130,229,94,108,17,35,0,0,6,0,141,175,86,59,5,162,79,85,166,8,70,112,13,32,13,24,64,67,26,24,71,255,7,123,211,12,80,121,11,69,215,15,66,217,11,69,71,10,131,113,132,
		126,119,90,9,66,117,19,132,19,32,0,130,0,24,64,47,59,33,7,0,73,227,5,68,243,15,85,13,12,76,37,22,74,254,15,130,138,33,0,4,65,111,6,137,79,65,107,16,32,1,77,200,6,34,128,128,3,75,154,
		12,37,0,16,0,0,2,0,104,115,36,140,157,68,67,19,68,51,15,106,243,15,134,120,70,37,10,68,27,10,140,152,65,121,24,32,128,94,155,7,67,11,8,24,74,11,25,65,3,12,83,89,18,82,21,37,67,200,
		5,130,144,24,64,172,12,33,4,0,134,162,74,80,14,145,184,32,0,130,0,69,251,20,32,19,81,243,5,82,143,8,33,5,53,89,203,5,133,112,79,109,15,33,0,21,130,71,80,175,41,36,75,0,79,0,83,121,
		117,9,87,89,27,66,103,11,70,13,15,75,191,11,135,67,87,97,20,109,203,5,69,246,8,108,171,5,78,195,38,65,51,13,107,203,11,77,3,17,24,75,239,17,65,229,28,79,129,39,130,175,32,128,123,253,
		7,132,142,24,65,51,15,65,239,41,36,128,128,0,0,13,65,171,5,66,163,28,136,183,118,137,11,80,255,15,67,65,7,74,111,8,32,0,130,157,32,253,24,76,35,10,103,212,5,81,175,9,69,141,7,66,150,
		29,131,158,24,75,199,28,124,185,7,76,205,15,68,124,14,32,3,123,139,16,130,16,33,128,128,108,199,6,33,0,3,65,191,35,107,11,6,73,197,11,24,70,121,15,83,247,15,24,70,173,23,69,205,14,
		32,253,131,140,32,254,136,4,94,198,9,32,3,78,4,13,66,127,13,143,13,32,0,130,0,33,16,0,24,69,59,39,109,147,12,76,253,19,24,69,207,15,69,229,15,130,195,71,90,10,139,10,130,152,73,43,
		40,91,139,10,65,131,37,35,75,0,79,0,84,227,12,143,151,68,25,15,80,9,23,95,169,11,34,128,2,128,112,186,5,130,6,83,161,19,76,50,6,130,37,65,145,44,110,83,5,32,16,67,99,6,71,67,15,76,
		55,17,140,215,67,97,23,76,69,15,77,237,11,104,211,23,77,238,11,65,154,43,33,0,10,83,15,28,83,13,20,67,145,19,67,141,14,97,149,21,68,9,15,86,251,5,66,207,5,66,27,37,82,1,23,127,71,12,
		94,235,10,110,175,24,98,243,15,132,154,132,4,24,66,69,10,32,4,67,156,43,130,198,35,2,1,0,4,75,27,9,69,85,9,95,240,7,32,128,130,35,32,28,66,43,40,24,82,63,23,83,123,12,72,231,15,127,
		59,23,116,23,19,117,71,7,24,77,99,15,67,111,15,71,101,8,36,2,128,128,252,128,127,60,11,32,1,132,16,130,18,141,24,67,107,9,32,3,68,194,15,175,15,38,0,11,0,128,1,128,2,80,63,25,32,0,
		24,65,73,11,69,185,15,83,243,16,32,0,24,81,165,8,130,86,77,35,6,155,163,88,203,5,24,66,195,30,70,19,19,24,80,133,15,32,1,75,211,8,32,254,108,133,8,79,87,20,65,32,9,41,0,0,7,0,128,0,
		0,2,128,2,68,87,15,66,1,16,92,201,16,24,76,24,17,133,17,34,128,0,30,66,127,64,34,115,0,119,73,205,9,66,43,11,109,143,15,24,79,203,11,90,143,15,131,15,155,31,65,185,15,86,87,11,35,128,
		128,253,0,69,7,6,130,213,33,1,0,119,178,15,142,17,66,141,74,83,28,6,36,7,0,0,4,128,82,39,18,76,149,12,67,69,21,32,128,79,118,15,32,0,130,0,32,8,131,206,32,2,79,83,9,100,223,14,102,
		113,23,115,115,7,24,65,231,12,130,162,32,4,68,182,19,130,102,93,143,8,69,107,29,24,77,255,12,143,197,72,51,7,76,195,15,132,139,85,49,15,130,152,131,18,71,81,23,70,14,11,36,0,10,0,128,
		2,69,59,9,89,151,15,66,241,11,76,165,12,71,43,15,75,49,13,65,12,23,132,37,32,0,179,115,130,231,95,181,16,132,77,32,254,67,224,8,65,126,20,79,171,8,32,2,89,81,5,75,143,6,80,41,8,34,
		2,0,128,24,81,72,9,32,0,130,0,35,17,0,0,255,77,99,39,95,65,36,67,109,15,24,69,93,11,77,239,5,95,77,23,35,128,1,0,128,24,86,7,8,132,167,32,2,69,198,41,130,202,33,0,26,120,75,44,24,89,
		51,15,71,243,12,70,239,11,24,84,3,11,66,7,11,71,255,10,32,21,69,155,35,88,151,12,32,128,74,38,10,65,210,8,74,251,5,65,226,5,75,201,13,32,3,65,9,41,146,41,40,0,0,0,9,1,0,1,0,2,91,99,
		19,32,35,106,119,13,70,219,15,83,239,12,137,154,32,2,67,252,19,36,128,0,0,4,1,130,196,32,2,130,8,91,107,8,32,0,135,81,24,73,211,8,132,161,73,164,13,36,0,8,0,128,2,105,123,26,139,67,
		76,99,15,34,1,0,128,135,76,83,156,20,92,104,8,67,251,30,24,86,47,27,123,207,12,24,86,7,15,71,227,8,32,4,65,20,20,131,127,32,0,130,123,32,0,71,223,26,32,19,90,195,22,71,223,15,84,200,
		6,32,128,133,241,24,84,149,9,67,41,25,36,0,0,0,22,0,88,111,49,32,87,66,21,5,77,3,27,123,75,7,71,143,19,135,183,71,183,19,130,171,74,252,5,131,5,89,87,17,32,1,132,18,130,232,68,11,10,
		33,1,128,70,208,16,66,230,18,147,18,130,254,223,255,75,27,23,65,59,15,135,39,155,255,34,128,128,254,104,92,8,33,0,128,65,32,11,65,1,58,33,26,0,130,0,72,71,18,78,55,17,76,11,19,86,101,
		12,75,223,11,89,15,11,24,76,87,15,75,235,15,131,15,72,95,7,85,71,11,72,115,11,73,64,6,34,1,128,128,66,215,9,34,128,254,128,134,14,33,128,255,67,102,5,32,0,130,16,70,38,11,66,26,57,
		88,11,8,24,76,215,34,78,139,7,95,245,7,32,7,24,73,75,23,32,128,131,167,130,170,101,158,9,82,49,22,118,139,6,32,18,67,155,44,116,187,9,108,55,14,80,155,23,66,131,15,93,77,10,131,168,
		32,128,73,211,12,24,75,187,22,32,4,96,71,20,67,108,19,132,19,120,207,8,32,5,76,79,15,66,111,21,66,95,8,32,3,190,211,111,3,8,211,212,32,20,65,167,44,34,75,0,79,97,59,13,32,33,112,63,
		10,65,147,19,69,39,19,143,39,24,66,71,9,130,224,65,185,43,94,176,12,65,183,24,71,38,8,24,72,167,7,65,191,38,136,235,24,96,167,12,65,203,62,115,131,13,65,208,42,175,235,67,127,6,32,
		4,76,171,29,114,187,5,32,71,65,211,5,65,203,68,72,51,8,164,219,32,0,172,214,71,239,58,78,3,27,66,143,15,77,19,15,147,31,35,33,53,51,21,66,183,10,173,245,66,170,30,150,30,34,0,0,23,
		80,123,54,76,1,16,73,125,15,82,245,11,167,253,24,76,85,12,70,184,5,32,254,131,185,37,254,0,128,1,0,128,133,16,117,158,18,92,27,38,65,3,17,130,251,35,17,0,128,254,24,69,83,39,140,243,
		121,73,19,109,167,7,81,41,15,24,95,175,12,102,227,15,121,96,11,24,95,189,7,32,3,145,171,154,17,24,77,47,9,33,0,5,70,71,37,68,135,7,32,29,117,171,11,69,87,15,24,79,97,19,24,79,149,23,
		131,59,32,1,75,235,5,72,115,11,72,143,7,132,188,71,27,46,131,51,32,0,69,95,6,175,215,32,21,131,167,81,15,19,151,191,151,23,131,215,71,43,5,32,254,24,79,164,24,74,109,8,77,166,13,65,
		176,26,88,162,5,98,159,6,171,219,120,247,6,79,29,8,99,169,10,103,59,19,65,209,35,131,35,91,25,19,112,94,15,83,36,8,173,229,33,20,0,88,75,43,71,31,12,65,191,71,33,1,0,130,203,32,254,
		131,4,68,66,7,67,130,6,104,61,13,173,215,38,13,1,0,0,0,2,128,67,111,28,74,129,16,104,35,19,79,161,16,87,14,7,138,143,132,10,67,62,36,114,115,5,162,151,67,33,16,108,181,15,143,151,67,
		5,5,24,100,242,15,170,153,34,0,0,14,65,51,34,32,55,79,75,9,32,51,74,7,10,65,57,38,132,142,32,254,72,0,14,139,163,32,128,80,254,8,67,158,21,65,63,7,32,4,72,227,27,95,155,12,67,119,19,
		124,91,24,149,154,72,177,34,97,223,8,155,151,24,108,227,15,88,147,16,72,117,19,68,35,11,92,253,15,70,199,15,24,87,209,17,32,2,87,233,7,32,1,24,88,195,10,119,24,8,32,3,81,227,24,65,
		125,21,35,128,128,0,25,76,59,48,24,90,187,9,97,235,12,66,61,11,91,105,19,24,79,141,11,24,79,117,15,24,79,129,27,90,53,13,130,13,32,253,131,228,24,79,133,40,69,70,8,66,137,31,65,33,
		19,96,107,8,68,119,29,66,7,5,68,125,16,65,253,19,65,241,27,24,90,179,13,24,79,143,18,33,128,128,130,246,32,254,130,168,68,154,36,77,51,9,97,47,5,167,195,32,21,131,183,78,239,27,155,
		195,78,231,14,201,196,77,11,6,32,5,73,111,37,97,247,12,77,19,31,155,207,78,215,19,162,212,69,17,14,66,91,19,80,143,57,78,203,39,159,215,32,128,93,134,8,24,80,109,24,66,113,15,169,215,
		66,115,6,32,4,69,63,33,32,0,101,113,7,86,227,35,143,211,36,49,53,51,21,1,77,185,14,65,159,28,69,251,34,67,56,8,33,9,0,24,107,175,25,90,111,12,110,251,11,119,189,24,119,187,34,87,15,
		9,32,4,66,231,37,90,39,7,66,239,8,84,219,15,69,105,23,24,85,27,27,87,31,11,33,1,128,76,94,6,32,1,85,241,7,33,128,128,106,48,10,33,128,128,69,136,11,133,13,24,79,116,49,84,236,8,24,
		91,87,9,32,5,165,255,69,115,12,66,27,15,159,15,24,72,247,12,74,178,5,24,80,64,15,33,0,128,143,17,77,89,51,130,214,24,81,43,7,170,215,74,49,8,159,199,143,31,139,215,69,143,5,32,254,
		24,81,50,35,181,217,84,123,70,143,195,159,15,65,187,16,66,123,7,65,175,15,65,193,29,68,207,39,79,27,5,70,131,6,32,4,68,211,33,33,67,0,83,143,14,159,207,143,31,140,223,33,0,128,24,80,
		82,14,24,93,16,23,32,253,65,195,5,68,227,40,133,214,107,31,7,32,5,67,115,27,87,9,8,107,31,43,66,125,6,32,0,103,177,23,131,127,72,203,36,32,0,110,103,8,155,163,73,135,6,32,19,24,112,
		99,10,65,71,11,73,143,19,143,31,126,195,5,24,85,21,9,24,76,47,14,32,254,24,93,77,36,68,207,11,39,25,0,0,255,128,3,128,4,66,51,37,95,247,13,82,255,24,76,39,19,147,221,66,85,27,24,118,
		7,8,24,74,249,12,76,74,8,91,234,8,67,80,17,131,222,33,253,0,121,30,44,73,0,16,69,15,6,32,0,65,23,38,69,231,12,65,179,6,98,131,16,86,31,27,24,108,157,14,80,160,8,24,65,46,17,33,4,0,
		96,2,18,144,191,65,226,8,68,19,5,171,199,80,9,15,180,199,67,89,5,32,255,24,79,173,28,174,201,24,79,179,50,32,1,24,122,5,10,82,61,10,180,209,83,19,8,32,128,24,80,129,27,111,248,43,131,
		71,24,115,103,8,67,127,41,78,213,24,100,247,19,66,115,39,75,107,5,32,254,165,219,78,170,40,24,112,163,49,32,1,97,203,6,65,173,64,32,0,83,54,7,133,217,88,37,12,32,254,131,28,33,128,
		3,67,71,44,84,183,6,32,5,69,223,33,96,7,7,123,137,16,192,211,24,112,14,9,32,255,67,88,29,68,14,10,84,197,38,33,0,22,116,47,50,32,87,106,99,9,116,49,15,89,225,15,97,231,23,70,41,19,
		82,85,8,93,167,6,32,253,132,236,108,190,7,89,251,5,116,49,58,33,128,128,131,234,32,15,24,74,67,38,70,227,24,24,83,45,23,89,219,12,70,187,12,89,216,19,32,2,69,185,24,141,24,70,143,66,
		24,82,119,56,78,24,10,32,253,133,149,132,6,24,106,233,7,69,198,48,178,203,81,243,12,68,211,15,106,255,23,66,91,15,69,193,7,100,39,10,24,83,72,16,176,204,33,19,0,88,207,45,68,21,12,
		68,17,10,65,157,53,68,17,6,32,254,92,67,10,65,161,25,69,182,43,24,118,91,47,69,183,18,181,209,111,253,12,89,159,8,66,112,12,69,184,45,35,0,0,0,9,24,80,227,26,73,185,16,118,195,15,131,
		15,33,1,0,65,59,15,66,39,27,160,111,66,205,12,148,111,143,110,33,128,128,156,112,24,81,199,8,75,199,23,66,117,20,155,121,32,254,68,126,12,72,213,29,134,239,149,123,89,27,16,148,117,
		65,245,8,24,71,159,14,141,134,134,28,73,51,55,109,77,15,105,131,11,68,67,11,76,169,27,107,209,12,102,174,8,32,128,72,100,18,116,163,56,79,203,11,75,183,44,85,119,19,71,119,23,151,227,
		32,1,93,27,8,65,122,5,77,102,8,110,120,20,66,23,8,66,175,17,66,63,12,133,12,79,35,8,74,235,33,67,149,16,69,243,15,78,57,15,69,235,16,67,177,7,151,192,130,23,67,84,29,141,192,174,187,
		77,67,15,69,11,12,159,187,77,59,10,199,189,24,70,235,50,96,83,19,66,53,23,105,65,19,77,47,12,163,199,66,67,37,78,207,50,67,23,23,174,205,67,228,6,71,107,13,67,22,14,66,85,11,83,187,
		38,124,47,49,95,7,19,66,83,23,67,23,19,24,96,78,17,80,101,16,71,98,40,33,0,7,88,131,22,24,89,245,12,84,45,12,102,213,5,123,12,9,32,2,126,21,14,43,255,0,128,128,0,0,20,0,128,255,128,
		3,126,19,39,32,75,106,51,7,113,129,15,24,110,135,19,126,47,15,115,117,11,69,47,11,32,2,109,76,9,102,109,9,32,128,75,2,10,130,21,32,254,69,47,6,32,3,94,217,47,32,0,65,247,10,69,15,46,
		65,235,31,65,243,15,101,139,10,66,174,14,65,247,16,72,102,28,69,17,14,84,243,9,165,191,88,47,48,66,53,12,32,128,71,108,6,203,193,32,17,75,187,42,73,65,16,65,133,52,114,123,9,167,199,
		69,21,37,86,127,44,75,171,11,180,197,78,213,12,148,200,81,97,46,24,95,243,9,32,4,66,75,33,113,103,9,87,243,36,143,225,24,84,27,31,90,145,8,148,216,67,49,5,24,84,34,14,75,155,27,67,
		52,13,140,13,36,0,20,0,128,255,24,135,99,46,88,59,43,155,249,80,165,7,136,144,71,161,23,32,253,132,33,32,254,88,87,44,136,84,35,128,0,0,21,81,103,5,94,47,44,76,51,12,143,197,151,15,
		65,215,31,24,64,77,13,65,220,20,65,214,14,71,4,40,65,213,13,32,0,130,0,35,21,1,2,0,135,0,34,36,0,72,134,10,36,1,0,26,0,130,134,11,36,2,0,14,0,108,134,11,32,3,138,23,32,4,138,11,34,
		5,0,20,134,33,34,0,0,6,132,23,32,1,134,15,32,18,130,25,133,11,37,1,0,13,0,49,0,133,11,36,2,0,7,0,38,134,11,36,3,0,17,0,45,134,11,32,4,138,35,36,5,0,10,0,62,134,23,32,6,132,23,36,3,
		0,1,4,9,130,87,131,167,133,11,133,167,133,11,133,167,133,11,37,3,0,34,0,122,0,133,11,133,167,133,11,133,167,133,11,133,167,34,50,0,48,130,1,34,52,0,47,134,5,8,49,49,0,53,98,121,32,
		84,114,105,115,116,97,110,32,71,114,105,109,109,101,114,82,101,103,117,108,97,114,84,84,88,32,80,114,111,103,103,121,67,108,101,97,110,84,84,50,48,48,52,47,130,2,53,49,53,0,98,0,121,
		0,32,0,84,0,114,0,105,0,115,0,116,0,97,0,110,130,15,32,71,132,15,36,109,0,109,0,101,130,9,32,82,130,5,36,103,0,117,0,108,130,29,32,114,130,43,34,84,0,88,130,35,32,80,130,25,34,111,
		0,103,130,1,34,121,0,67,130,27,32,101,132,59,32,84,130,31,33,0,0,65,155,9,34,20,0,0,65,11,6,130,8,135,2,33,1,1,130,9,8,120,1,1,2,1,3,1,4,1,5,1,6,1,7,1,8,1,9,1,10,1,11,1,12,1,13,1,14,
		1,15,1,16,1,17,1,18,1,19,1,20,1,21,1,22,1,23,1,24,1,25,1,26,1,27,1,28,1,29,1,30,1,31,1,32,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0,15,0,16,0,17,0,18,0,19,0,20,0,21,0,
		22,0,23,0,24,0,25,0,26,0,27,0,28,0,29,0,30,0,31,130,187,8,66,33,0,34,0,35,0,36,0,37,0,38,0,39,0,40,0,41,0,42,0,43,0,44,0,45,0,46,0,47,0,48,0,49,0,50,0,51,0,52,0,53,0,54,0,55,0,56,0,
		57,0,58,0,59,0,60,0,61,0,62,0,63,0,64,0,65,0,66,130,243,9,75,68,0,69,0,70,0,71,0,72,0,73,0,74,0,75,0,76,0,77,0,78,0,79,0,80,0,81,0,82,0,83,0,84,0,85,0,86,0,87,0,88,0,89,0,90,0,91,0,
		92,0,93,0,94,0,95,0,96,0,97,1,33,1,34,1,35,1,36,1,37,1,38,1,39,1,40,1,41,1,42,1,43,1,44,1,45,1,46,1,47,1,48,1,49,1,50,1,51,1,52,1,53,1,54,1,55,1,56,1,57,1,58,1,59,1,60,1,61,1,62,1,
		63,1,64,1,65,0,172,0,163,0,132,0,133,0,189,0,150,0,232,0,134,0,142,0,139,0,157,0,169,0,164,0,239,0,138,0,218,0,131,0,147,0,242,0,243,0,141,0,151,0,136,0,195,0,222,0,241,0,158,0,170,
		0,245,0,244,0,246,0,162,0,173,0,201,0,199,0,174,0,98,0,99,0,144,0,100,0,203,0,101,0,200,0,202,0,207,0,204,0,205,0,206,0,233,0,102,0,211,0,208,0,209,0,175,0,103,0,240,0,145,0,214,0,
		212,0,213,0,104,0,235,0,237,0,137,0,106,0,105,0,107,0,109,0,108,0,110,0,160,0,111,0,113,0,112,0,114,0,115,0,117,0,116,0,118,0,119,0,234,0,120,0,122,0,121,0,123,0,125,0,124,0,184,0,
		161,0,127,0,126,0,128,0,129,0,236,0,238,0,186,14,117,110,105,99,111,100,101,35,48,120,48,48,48,49,141,14,32,50,141,14,32,51,141,14,32,52,141,14,32,53,141,14,32,54,141,14,32,55,141,
		14,32,56,141,14,32,57,141,14,32,97,141,14,32,98,141,14,32,99,141,14,32,100,141,14,32,101,141,14,32,102,140,14,33,49,48,141,14,141,239,32,49,141,239,32,49,141,239,32,49,141,239,32,49,
		141,239,32,49,141,239,32,49,141,239,32,49,141,239,32,49,141,239,32,49,141,239,32,49,141,239,32,49,141,239,32,49,141,239,32,49,141,239,45,49,102,6,100,101,108,101,116,101,4,69,117,114,
		111,140,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,
		32,56,141,236,32,56,141,236,32,56,65,220,13,32,57,65,220,13,32,57,141,239,32,57,141,239,32,57,141,239,32,57,141,239,32,57,141,239,32,57,141,239,32,57,141,239,32,57,141,239,32,57,141,
		239,32,57,141,239,32,57,141,239,32,57,141,239,32,57,141,239,32,57,141,239,35,57,102,0,0,5,250,72,249,98,247,
	};

	static bool renderFrameContent(const char* title, bool* value, void(*insert)())
	{
		ImGui::BeginGroup();
		ImGui::PushID("frame");

		ImDrawList* drawList = ImGui::GetWindowDrawList();
		float getFrameHeight = ImGui::GetFrameHeight();
		float removedSize = 5.5f; // reduce few pixels
		float halfSize = (getFrameHeight) / 2.0f - removedSize;

		ImVec2 vec = ImGui::GetCursorScreenPos();

		float screenPosX = vec.x;
		float screenPosY = vec.y;
		float arrowPaddingLeft = 6;

		float x = screenPosX + halfSize + arrowPaddingLeft;
		float y = screenPosY + getFrameHeight / 2.0f;

		bool hovered = ImGui::IsMouseHoveringRect(ImVec2(x - halfSize - removedSize, y - halfSize - removedSize),
			ImVec2(x + halfSize + removedSize, y + halfSize + removedSize));

		ImGuiStyle& style = ImGui::GetStyle();
		
		ImColor whiteColor = ImGui::GetColorU32(ImVec4(255.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f));

		float triA_X = 0;
		float triA_Y = 0;
		float triB_X = 0;
		float triB_Y = 0;
		float triC_X = 0;
		float triC_Y = 0;

		if (*value) {
			// arrow down
			float offset = -0.5f;
			triA_X = x - halfSize + offset;
			triA_Y = y - halfSize;
			triB_X = x + halfSize + offset;
			triB_Y = y - halfSize;
			triC_X = x + offset;
			triC_Y = y + halfSize;
		}
		else {
			// arrow right
			triA_X = x - halfSize;
			triA_Y = y - halfSize;
			triB_X = x + halfSize;
			triB_Y = y;
			triC_X = x - halfSize;
			triC_Y = y + halfSize;
		}

		ImVec2 textSize = ImGui::CalcTextSize(title, NULL);

		float offsetY = (getFrameHeight - textSize.y) / 2.0f;
		float offsetX = 5;

		drawList->AddText(ImVec2(x + halfSize * 2 + offsetX, screenPosY + offsetY), whiteColor, title, NULL);

		drawList->AddTriangleFilled(ImVec2(triA_X, triA_Y), ImVec2(triB_X, triB_Y), ImVec2(triC_X, triC_Y), whiteColor);

		ImGui::PopID();
		ImGui::EndGroup();

		if (insert)
		{
			ImGui::SetCursorScreenPos(ImVec2(offsetX + screenPosX, offsetY + screenPosY));
			(*insert)();
		}

		return *value;
	}

	bool BeginChildEx(const char* id, float sizeX, float paddingX, float paddingY)
	{
		ImGuiContext& g = *GImGui;
		ImGuiWindow* parent_window = g.CurrentWindow;

		ImGuiWindowFlags flags = 0;
		flags |= ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_AlwaysUseWindowPadding;
		flags |= (parent_window->Flags & ImGuiWindowFlags_NoMove);  // Inherit the NoMove flag

		//ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2{ 7.f, 7.f });

		const float backup_border_size = g.Style.ChildBorderSize;
		g.Style.ChildBorderSize = 0.0f;

		//
		bool ret = ImGui::BeginChild(id, { 0, 0 }, ImGuiChildFlags_AlwaysAutoResize | ImGuiChildFlags_AutoResizeY, flags);
		g.Style.ChildBorderSize = backup_border_size;

		//ImGui::PopStyleVar();

		return ret;
	};

	void EndChildEx()
	{
		ImGuiContext& g = *GImGui;
		ImGuiWindow* window = g.CurrentWindow;

		float bottomOffset = g.Style.ItemSpacing.y;
		float y = ImGui::GetCursorPosY() - bottomOffset;

		ImDrawList* drawList = ImGui::GetWindowDrawList();
		ImVec2 vec = ImGui::GetCursorStartPos();

		float windowX = window->ParentWindow->Pos.x + vec.x;
		float windowY = window->ParentWindow->Pos.y + vec.y;

		float windowPaddingX = windowX - window->ParentWindow->WindowPadding.x;
		float windowPaddingY = windowY - window->ParentWindow->WindowPadding.y;

		//float windowWidth = window->Size.x - window->WindowPadding.x * 2;
		float windowHeight = y - window->ParentWindow->WindowPadding.y;

		//float windowPaddingWidth = windowWidth + window->WindowPadding.x * 2;
		float windowPaddingHeight = windowHeight + window->ParentWindow->WindowPadding.y * 2;

		ImGui::SetWindowSize(ImVec2(window->ParentWindow->ContentSize.x, windowPaddingHeight));
		ImGui::EndChild();
	};

	bool BeginCollapsingHeaderEx(const char* id, const char* title, bool* isOpen, float sizeX, float paddingX, float paddingY)
	{
		// Allows for the use of a custom persistent bool
		if (isOpen == nullptr)
		{
			if (_IDToggleMap.count(id)) // Check if the ID Toggle Map already has a key with this ID
				isOpen = _IDToggleMap.at(id); // Use that value as this headers persistent bool
			else
			{
				isOpen = new bool(false); // The ID doesn't exist in the ID Toggle Map, create it
				_IDToggleMap[id] = isOpen; // Put it in the ID Toggle map
			}
		}

		ImGuiStyle& style = ImGui::GetStyle();
		ImGuiContext& g = *GImGui;
		float getFrameHeight = ImGui::GetFrameHeight();

		ImDrawList* drawList = ImGui::GetWindowDrawList();

		ImVec2 vec = ImGui::GetCursorScreenPos();
		float screenPosX = vec.x;
		float screenPosY = vec.y;
		float windowWidth = ImGui::GetWindowContentRegionMax().x - ImGui::GetWindowContentRegionMin().x - sizeX;

		ImGui::BeginGroup();

		ImGui::BeginGroup();
		ImGui::PushID("id");

		bool isDisabled = (g.CurrentItemFlags & ImGuiItemFlags_Disabled) != 0;
		// Checks to see if the whole window is hovered
		// This is to make sure that it isn't activated behind another window
		bool isWindowHovered = ImGui::IsWindowHovered();
		// Checks to see if the mouse is over the area given
		bool hovered = ImGui::IsMouseHoveringRect(ImVec2(screenPosX, screenPosY), ImVec2(screenPosX + windowWidth, screenPosY + getFrameHeight)) && !isDisabled;

		ImColor whiteColor = ImGui::GetColorU32(ImVec4(255.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f));

		// The color of the header, turns blue if hovered
		ImU32 frameColor = hovered && isWindowHovered ?
			ImGui::GetColorU32(style.Colors[ImGuiCol_HeaderHovered]) :
			ImGui::GetColorU32(ImVec4(0x24 / 255.0f, 0x24 / 255.0f, 0x24 / 255.0f, 255 / 255.0f));

		if (isWindowHovered && hovered) {
			if (ImGui::IsMouseDown(0))
				frameColor = ImGui::GetColorU32(style.Colors[ImGuiCol_HeaderActive]);
			if (ImGui::IsMouseReleased(0))
				*isOpen = !*isOpen;
		}

		if (isDisabled)
			*isOpen = false;

		int borderRound = 4;
		int roundingCorners = ImDrawFlags_RoundCornersAll;
		// Add header to draw list
		drawList->AddRectFilled(ImVec2(screenPosX, screenPosY), ImVec2(screenPosX + windowWidth, screenPosY + getFrameHeight), frameColor, borderRound, roundingCorners);

		bool flag = renderFrameContent(title, isOpen);

		ImGui::PopID();
		ImGui::EndGroup();

		float bk = g.Style.ItemSpacing.y;
		g.Style.ItemSpacing.y = 0;
		int offset = 0;

		if (flag)
			offset = bk;

		ImGui::ItemSize(ImVec2(windowWidth, getFrameHeight - offset));
		g.Style.ItemSpacing.y = bk;

		if (flag)
			ImGui::BeginChildEx(id, windowWidth, paddingX, paddingY);
		return flag;
	}

	bool BeginCollapsingHeaderWithInsert(const char* id, const char* title, void(*titleInsert)(), bool* isOpen, float sizeX, float paddingX, float paddingY)
	{
		// Allows for the use of a custom persistent bool
		if (isOpen == nullptr)
		{
			if (_IDToggleMap.count(id)) // Check if the ID Toggle Map already has a key with this ID
				isOpen = _IDToggleMap.at(id); // Use that value as this headers persistent bool
			else
			{
				isOpen = new bool(false); // The ID doesn't exist in the ID Toggle Map, create it
				_IDToggleMap[id] = isOpen; // Put it in the ID Toggle map
			}
		}

		ImGuiStyle& style = ImGui::GetStyle();
		ImGuiContext& g = *GImGui;
		float getFrameHeight = ImGui::GetFrameHeight();

		ImDrawList* drawList = ImGui::GetWindowDrawList();

		ImVec2 vec = ImGui::GetCursorScreenPos();
		float screenPosX = vec.x;
		float screenPosY = vec.y;
		float windowWidth = ImGui::GetWindowContentRegionMax().x - ImGui::GetWindowContentRegionMin().x;

		ImGui::BeginGroup();

		ImGui::BeginGroup();
		ImGui::PushID("id");

		bool isDisabled = (g.CurrentItemFlags & ImGuiItemFlags_Disabled) != 0;
		// Checks to see if the whole window is hovered
		// This is to make sure that it isn't activated behind another window
		bool isWindowHovered = ImGui::IsWindowHovered();
		// Checks to see if the mouse is over the area given
		bool hovered = ImGui::IsMouseHoveringRect(ImVec2(screenPosX, screenPosY), ImVec2(screenPosX + windowWidth, screenPosY + getFrameHeight)) && !isDisabled;

		ImColor whiteColor = ImGui::GetColorU32(ImVec4(255.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f));

		// The color of the header, turns blue if hovered
		ImU32 frameColor = hovered && isWindowHovered ?
			ImGui::GetColorU32(style.Colors[ImGuiCol_HeaderHovered]) :
			ImGui::GetColorU32(ImVec4(0x24 / 255.0f, 0x24 / 255.0f, 0x24 / 255.0f, 255 / 255.0f));

		if (isWindowHovered && hovered) {
			if (ImGui::IsMouseDown(0))
				frameColor = ImGui::GetColorU32(style.Colors[ImGuiCol_HeaderActive]);
			if (ImGui::IsMouseReleased(0))
				*isOpen = !*isOpen;
		}

		if (isDisabled)
			*isOpen = false;

		int borderRound = 4;
		int roundingCorners = ImDrawFlags_RoundCornersAll;
		// Add header to draw list
		drawList->AddRectFilled(ImVec2(screenPosX, screenPosY), ImVec2(screenPosX + windowWidth, screenPosY + getFrameHeight), frameColor, borderRound, roundingCorners);

		bool flag = renderFrameContent(title, isOpen, titleInsert);

		ImGui::PopID();
		ImGui::EndGroup();

		float bk = g.Style.ItemSpacing.y;
		g.Style.ItemSpacing.y = 0;
		int offset = 0;

		if (flag)
			offset = bk;

		ImGui::SetCursorScreenPos(ImVec2(vec.x, vec.y + bk));

		ImGui::ItemSize(ImVec2(windowWidth, getFrameHeight - offset));
		g.Style.ItemSpacing.y = bk;
		if (flag)
			ImGui::BeginChildEx(id, windowWidth, paddingX, paddingY);
		return flag;
	}


	void EndCollapsingHeaderEx(bool isOpen)
	{
		ImGuiContext& g = *GImGui;

		ImGuiWindow* childWindow = NULL;
		ImGuiWindow* parentWindow = NULL;

		float height = 0.0f;

		if (isOpen) {
			childWindow = g.CurrentWindow;

			float bottomOffset = g.Style.ItemSpacing.y;
			float y = ImGui::GetCursorPosY() - bottomOffset;
			ImVec2 vec = ImGui::GetCursorStartPos();

			float windowY = childWindow->Pos.y + vec.y;
			float windowPaddingY = windowY - childWindow->WindowPadding.y;
			float windowHeight = y - childWindow->WindowPadding.y;
			height = windowHeight + childWindow->WindowPadding.y * 2;

			ImGui::EndChildEx();
		}

		parentWindow = g.CurrentWindow;

		float bk = g.Style.ItemSpacing.y;

		if (!isOpen)
			g.Style.ItemSpacing.y = 0;
		ImGui::EndGroup();
		if (!isOpen)
			g.Style.ItemSpacing.y = bk;

		float getFrameHeight = ImGui::GetFrameHeight();
		ImVec2 vec = ImGui::GetCursorScreenPos();
		float screenPosX = parentWindow->DC.CursorPos.x;
		float screenPosY = parentWindow->DC.CursorPosPrevLine.y;

		float windowWidth = ImGui::GetWindowContentRegionMax().x - ImGui::GetWindowContentRegionMin().x;
		int offset = 0;
		if (isOpen)
			offset = g.Style.ItemSpacing.y;

		ImDrawList* drawList = ImGui::GetWindowDrawList();

		windowWidth = ImGui::GetWindowContentRegionMax().x - ImGui::GetWindowContentRegionMin().x;

		float rounding = 5;

		int roundingCorners = ImDrawFlags_RoundCornersAll;

		ImU32 borderColor = ImGui::GetColorU32(ImVec4(0x40 / 255.0f, 0x40 / 255.0f, 0x49 / 255.0f, 255 / 255.0f));

		drawList->AddRect(ImVec2(screenPosX, screenPosY), ImVec2(screenPosX + windowWidth, screenPosY + height + getFrameHeight), borderColor, rounding, roundingCorners, 1.0f);

	};

}

namespace lost
{

	static int min(int a, int b)
	{
		return a < b ? a : b;
	}

	void lost::setupImGui(float scale)
	{
#ifndef IMGUI_DISABLE
		// Get first window, will be nullptr if no window was created
		Window window = lost::getWindow(0);

#ifdef LOST_DEBUG_MODE
		// Note for users
		debugLogIf(lost::getWindows().size() > 1, "\n[ ImGui ] ImGui can only be used on one window!!\n[ ImGui ] You cannot run ImGui functions on any context other than the first one created!\n[ ImGui ] This is not an error\n", LOST_LOG_NONE);

		// Check if window is nullptr, crash the program if so
		debugLogIf(window == nullptr, "Tried to initialize ImGui while there was no window", LOST_LOG_FATAL);
		if (window->_hasImGui)
		{
			debugLog("Tried to initialize ImGui after it had already been initialized", LOST_LOG_WARNING);
			return;
		}
#endif

		// Initialize ImGui on window

		IMGUI_CHECKVERSION();
		ImGui::CreateContext();
		ImGuiIO& io = ImGui::GetIO();
		io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable Keyboard Controls
		io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls
		io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;         
		//io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable;
		//io.ConfigViewportsNoTaskBarIcon = true; 

		// Setup Platform/Renderer backends
		ImGui_ImplGlfw_InitForOpenGL(window->glfwWindow, true);          // Second param install_callback=true will install GLFW callbacks and chain to existing ones.
		ImGui_ImplOpenGL3_Init();

		window->_hasImGui = true;
		_setUsingImGui(true);

		ImFont* font = io.Fonts->AddFontFromMemoryCompressedTTF(ImGui::proggy_clean_ttf_compressed_data, ImGui::proggy_clean_ttf_compressed_size, 16.0f * scale);
		io.Fonts->Build();
		ImGui::GetIO().FontDefault = font;

		debugLog("ImGui successfully initialized on window! (ImGui can be disabled by defining IMGUI_DISABLE)", LOST_LOG_SUCCESS);
#endif
	}

	void _closeImGui()
	{
#ifndef IMGUI_DISABLE
		// Get invisible window, will be nullptr if no window was created
		Window window = lost::getWindow(0);

#ifdef LOST_DEBUG_MODE
		// Check if window is nullptr, crash the program if so
		debugLogIf(window == nullptr, "Tried to close ImGui while there was no window", LOST_LOG_FATAL);
		if (!window->_hasImGui)
		{
			debugLog("Tried to close ImGui after it had already been closed", LOST_LOG_WARNING);
			return;
		}
#endif

		ImGui_ImplOpenGL3_Shutdown();
		ImGui_ImplGlfw_Shutdown();
		ImGui::DestroyContext();

		window->_hasImGui = false;

		debugLog("ImGui successfully closed on window", LOST_LOG_SUCCESS);
		
		// Clear the _IDToggleMap
		// [?] Putting it here is kinda weird, it's in the Lost namespace
		for (typename std::map<std::string, bool*>::iterator it = ImGui::_IDToggleMap.begin(); it != ImGui::_IDToggleMap.end(); it++)
		{
			delete (*it).second;
		}
#endif
	}

	std::string selectFileToOpen()
	{
		wchar_t filename[MAX_PATH];

		OPENFILENAME ofn;
		ZeroMemory(&filename, sizeof(filename));
		ZeroMemory(&ofn, sizeof(ofn));
		ofn.lStructSize = sizeof(ofn);
		ofn.hwndOwner = NULL;  // If you have a window to center over, put its HANDLE here
		ofn.lpstrFilter = _T("PNG File\0*.png\0");
		ofn.lpstrFile = filename;
		ofn.nMaxFile = MAX_PATH;
		ofn.lpstrTitle = _T("Select a File");
		ofn.Flags = OFN_DONTADDTORECENT | OFN_FILEMUSTEXIST;

		if (GetOpenFileName(&ofn))
		{
			std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
			std::string narrow = converter.to_bytes(filename);
			return narrow;
		}
		else
		{
			// All this stuff below is to tell you exactly how you messed up above. 
			// Once you've got that fixed, you can often (not always!) reduce it to a 'user cancelled' assumption.
			switch (CommDlgExtendedError())
			{
			case CDERR_DIALOGFAILURE: std::cout << "CDERR_DIALOGFAILURE\n";   break;
			case CDERR_FINDRESFAILURE: std::cout << "CDERR_FINDRESFAILURE\n";  break;
			case CDERR_INITIALIZATION: std::cout << "CDERR_INITIALIZATION\n";  break;
			case CDERR_LOADRESFAILURE: std::cout << "CDERR_LOADRESFAILURE\n";  break;
			case CDERR_LOADSTRFAILURE: std::cout << "CDERR_LOADSTRFAILURE\n";  break;
			case CDERR_LOCKRESFAILURE: std::cout << "CDERR_LOCKRESFAILURE\n";  break;
			case CDERR_MEMALLOCFAILURE: std::cout << "CDERR_MEMALLOCFAILURE\n"; break;
			case CDERR_MEMLOCKFAILURE: std::cout << "CDERR_MEMLOCKFAILURE\n";  break;
			case CDERR_NOHINSTANCE: std::cout << "CDERR_NOHINSTANCE\n";     break;
			case CDERR_NOHOOK: std::cout << "CDERR_NOHOOK\n";          break;
			case CDERR_NOTEMPLATE: std::cout << "CDERR_NOTEMPLATE\n";      break;
			case CDERR_STRUCTSIZE: std::cout << "CDERR_STRUCTSIZE\n";      break;
			case FNERR_BUFFERTOOSMALL: std::cout << "FNERR_BUFFERTOOSMALL\n";  break;
			case FNERR_INVALIDFILENAME: std::cout << "FNERR_INVALIDFILENAME\n"; break;
			case FNERR_SUBCLASSFAILURE: std::cout << "FNERR_SUBCLASSFAILURE\n"; break;
			default: std::cout << "You cancelled.\n";
			}
			return "";
		}
	}

	struct _imGuiTextureViewer
	{
		_imGuiTextureViewer(typename std::map<std::string, DataCount<Texture>>::const_iterator tex)
			: value{ tex }
		{

		};

		~_imGuiTextureViewer()
		{

		};

		void render(int id)
		{
			ImGui::PushID(id);
			ImGui::Begin((std::string("Texture Viewer: ") + value->first + "##" + value->first).c_str(), &shouldBeOpen, 0);

			ImVec2 bounds = ImGui::GetWindowSize();

			float aspect = (float)value->second.data->getHeight() / (float)value->second.data->getWidth();
			float imageScaleX = bounds.x * imageRatio;
			float imageScaleY = bounds.y / aspect - (ImGui::GetWindowSize().y - ImGui::GetContentRegionAvail().y);
			float imageScale = fminf(imageScaleX, imageScaleY);

			ImGui::Image((ImTextureID)(intptr_t)(value->second.data->getTexture()), { imageScale, imageScale * aspect });

			ImGui::SameLine();
			ImGui::BeginGroup();

			ImGui::SeparatorText("Image Info");
			ImGui::Text("Image ID: %s", value->first.c_str());
			ImGui::Text("Image Location: %s", value->second.data->getDirectory());

			bool isLoadedImage = std::string(value->second.data->getDirectory()) == "No directory";

			// Change image file
			ImGui::BeginDisabled(isLoadedImage);
			if (ImGui::Button("Change Image", { ImGui::GetContentRegionAvail().x, 0 }))
			{
				// Open file selection window
				std::string fileSelected = selectFileToOpen();
				if (!fileSelected.empty())
				{
					// Swap image
					value->second.data->loadTexture(fileSelected.c_str());
				}
			}

			if (ImGui::Button("Reload Image", { ImGui::GetContentRegionAvail().x, 0 }))
				value->second.data->loadTexture(value->second.data->getDirectory());
			ImGui::EndDisabled();

			ImGui::SeparatorText("Image Data");
			ImGui::Text("Width: %i", value->second.data->getWidth());
			ImGui::Text("Height: %i", value->second.data->getHeight());

			ImGui::EndGroup();

			ImGui::End();
			ImGui::PopID();
		}

		float imageRatio = 0.4;

		bool shouldBeOpen = true;
		typename std::map<std::string, DataCount<Texture>>::const_iterator value;
	};

	std::vector<_imGuiTextureViewer*> textureViews;

	struct UniformSelection
	{
		int selectedUniformIndex = 0;

		const char* selectedUniformName = nullptr;
		bool liveSet = false;

		unsigned int offset = 0;

		union
		{
			float		  fv[4] = { 0b0, 0b0, 0b0, 0b0 };
			int			  iv[4];
			unsigned int uiv[4];
			double		  dv[4];
			bool          bv[4];
		};
	};

	static class FrameHistory
	{
	public:
		FrameHistory()
		{
			// 0 out frame time history
			for (int i = 0; i < frameCount; i++)
				frameTimeHistory[i] = 0.0f;
		}

		void addFrameTime(float frameTime)
		{

			if (!acceptNewInputs) // Escape if not accepting any new inputs
				return;

			cursor++;
			if (cursor >= frameCount) // Loop back around
				cursor = 0;

			if (frameTime > maxTime) // Update the max time if this is the biggest it's seen
			{
				maxTime = frameTime;
				maxPoint = cursor;
			}
			else if (maxTime == frameTimeHistory[cursor]) // Update the max time if this overrode the biggest value
			{
				float maxVal = 0.0f;
				for (int i = 0; i < frameCount; i++)
				{
					if (i == cursor)
						continue;

					if (frameTimeHistory[i] > maxVal)
					{
						maxVal = frameTimeHistory[i];
						maxPoint = i;
					}
				}
				maxTime = maxVal;
			}

			if (maxTime < 1000.0f / clipFPS)
				maxTime = 1000.0f / clipFPS;

			averageFrameTime += frameTime / frameCount;
			averageFrameTime -= frameTimeHistory[cursor] / frameCount;

			frameTimeHistory[cursor] = frameTime;
		}

		void _imGuiDisplayFrameTimeInfo()
		{
			ImDrawList* drawList = ImGui::GetWindowDrawList();
			ImGuiStyle& style = ImGui::GetStyle();

			int borderRound = 8;
			int roundingCorners = ImDrawFlags_RoundCornersAll;
			int graphHeight = 300;

			ImColor fillColor = { 4, 4, 7, 255 };
			ImColor borderColor = { 0x40, 0x40, 0x49, 255 };

			ImVec2 cursorPos = ImGui::GetCursorPos();
			ImVec2 min = ImGui::GetCursorScreenPos();
			ImVec2 max = { ImGui::GetContentRegionAvail().x + ImGui::GetCursorScreenPos().x, ImGui::GetCursorScreenPos().y + graphHeight };

			drawList->AddRectFilled(min, max, fillColor, borderRound, roundingCorners);
			drawList->AddRect(min, max, borderColor, borderRound, roundingCorners);

			ImGui::SetCursorPos({ cursorPos.x + 1, cursorPos.y + 1 });
			ImGui::BeginChild("##LOST_frameTimeMenu", ImVec2{ ImGui::GetContentRegionAvail().x - 1.0f, (float)graphHeight - 2.0f }, ImGuiChildFlags_None | ImGuiChildFlags_AlwaysUseWindowPadding, ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_NoBackground);
			ImVec2 oldCursorPos = ImGui::GetCursorPos();

			if (enabled)
			{
				ImVec4 extraPadding = { 70.0f, 20.0f, 70.0f, 20.0f };

				ImGui::SetCursorPos({ 20, 20 });
				
				ImVec2 topRight = { ImGui::GetContentRegionAvail().x + ImGui::GetCursorScreenPos().x - (20 - style.FramePadding.x), ImGui::GetCursorScreenPos().y };

				bool tempInverse = !acceptNewInputs;
				ImGui::Checkbox("Pause##Lost_frameTimeButtonTest", &tempInverse);
				if (tempInverse != !acceptNewInputs)
					acceptNewInputs = !tempInverse;

				std::string averageText = std::string("Max: ") + ((maxTime <= (1000.0f/ clipFPS)) ? "<" : "") + std::to_string(maxTime) + "ms / Average: " + std::to_string(averageFrameTime) + "ms / " + std::to_string((int)round(1000.0f / averageFrameTime)) + "fps";
				ImVec2 textSize = ImGui::CalcTextSize(averageText.c_str());
				drawList->AddText({ topRight.x - textSize.x, topRight.y }, ImColor{ 135, 191, 255, 255 }, averageText.c_str());

				ImVec2 innerMin = { ImGui::GetCursorScreenPos().x + extraPadding.x, ImGui::GetCursorScreenPos().y + extraPadding.y };

				ImVec2 innerMax = { ImGui::GetContentRegionAvail().x + ImGui::GetCursorScreenPos().x - extraPadding.z, ImGui::GetContentRegionAvail().y + ImGui::GetCursorScreenPos().y - extraPadding.w };

				ImColor barColor = { 100, 125, 240, 255 };
				float barWidth = (innerMax.x - innerMin.x) / frameCount;
				float barHeight = (innerMax.y - innerMin.y);
				float scale = 1.0f / maxTime;

				ImColor graphLineCol = { 255, 255, 255, 255 };
				ImColor graphSecondaryLineCol = { 100, 100, 100, 255 };
				// Axis'
				drawList->AddLine({ innerMin.x - 1, innerMax.y }, { innerMax.x + 1, innerMax.y }, graphLineCol);
				drawList->AddLine({ innerMin.x - 1, innerMax.y }, { innerMin.x - 1, innerMin.y }, graphLineCol);
				drawList->AddLine({ innerMax.x,     innerMax.y }, { innerMax.x,     innerMin.y }, graphLineCol);
				// Extra lines
				float frameGoalLineSpacing = 180.0f;
				float timeGoalLineSpacing = 1000.0f / frameGoalLineSpacing;
				int lineCount = (int)(maxTime / timeGoalLineSpacing);
				int increment = (int)(lineCount / 10) + 1;

				for (int i = 1; i <= lineCount; i += increment)
				{
					float lineY = innerMax.y - barHeight * timeGoalLineSpacing * i * scale;
					drawList->AddLine({ innerMin.x, lineY }, { innerMax.x, lineY }, graphSecondaryLineCol);

					int fpsVal = frameGoalLineSpacing / i;
					std::string frameLabel = std::to_string(fpsVal) + "fps";
					ImVec2 textSize = ImGui::CalcTextSize(frameLabel.c_str());
					ImVec2 framePos = { innerMin.x - textSize.x - 5.0f, lineY - textSize.y / 2.0f };
					drawList->AddText(framePos, graphLineCol, frameLabel.c_str());

					int msVal = (float)(i / frameGoalLineSpacing) * 1000.0f;
					std::string msLabel = std::to_string(msVal) + "ms";
					textSize = ImGui::CalcTextSize(msLabel.c_str());
					ImVec2 msPos = { innerMax.x + 5.0f, lineY - textSize.y / 2.0f };
					drawList->AddText(msPos, graphLineCol, msLabel.c_str());
				}

				for (int i = 0; i < frameCount; i++)
				{
					int offset = cursor - frameCount + (i + 1);
					if (offset < 0)
						offset += frameCount;

					if (frameTimeHistory[offset] == maxTime)
						barColor = { 150, 10, 20, 255 };
					else
						barColor = { 100, 125, 240, 255 };

					ImVec2 barMin = { (innerMin.x + barWidth * i),      (innerMax.y - barHeight * frameTimeHistory[offset] * scale) };
					ImVec2 barMax = { (innerMin.x + barWidth * (i + 1)), innerMax.y };
					drawList->AddRectFilled(barMin, barMax, barColor);
				}
			}
			else
			{
				ImVec2 pos = { (max.x + min.x) / 2.0f, (max.y + min.y) / 2.0f };
				ImVec2 textSize = ImGui::CalcTextSize("The frame time graph is currently dissabled");
				pos = { pos.x - textSize.x / 2.0f, pos.y - textSize.y / 2.0f };
				drawList->AddText(pos, ImColor{ 255, 255, 255, 255 }, "The frame time graph is currently dissabled");

				if (ImGui::Button("Enable"))
					enabled = true;
			}

			ImGui::EndChild();

			ImGui::SetCursorPos({ cursorPos.x, cursorPos.y + graphHeight + style.ItemSpacing.y });
		}

	private:
		unsigned int cursor = 0; // The point which is considered address "199"

		float averageFrameTime = 0.0f;

		float clipFPS = 60.0f;

		unsigned int frameCount = LOST_FRAME_RATE_HISTORY_COUNT;
		bool enabled = LOST_FRAME_RATE_HISTORY_ENABLED;

		float frameTimeHistory[LOST_FRAME_RATE_HISTORY_COUNT];

		bool acceptNewInputs = true;

		unsigned int maxPoint = 0;
		float maxTime = 0.0f;
	} frameHistory = {};

	std::map<std::string, UniformSelection> uniformSelectors;

	// Is ran inside of a child window
	void _imGuiDisplayTextureAssetList()
	{
		ImVec2 buttonSize = { 100.0f, 100.0f };

		// Get the bounds that the buttons can be rendered to 
		float windowMaxX = ImGui::GetCursorScreenPos().x + ImGui::GetWindowContentRegionMax().x - ImGui::GetWindowContentRegionMin().x;

		ImGuiStyle& style = ImGui::GetStyle();
		int textureCount = _textureRM->getValueCount();

		int yPos = ImGui::GetCursorPosY();

		// Loop through all loaded textures
		const std::map<std::string, DataCount<Texture>>& dataMap = _textureRM->getDataMap();

		if (dataMap.empty())
		{
			ImGui::TextDisabled("No Textures Loaded...");
			return;
		}

		int index = 0;
		for (typename std::map<std::string, DataCount<Texture>>::const_iterator it = dataMap.begin(); it != dataMap.end(); it++)
		{
			ImGui::PushID(index);

			// If any of the buttons are pressed create a texture view window
			if (ImGui::ImageButton("Box", (ImTextureID)(intptr_t)(it->second.data->getTexture()), buttonSize))
				textureViews.push_back(new _imGuiTextureViewer(it));

			// Wrap the buttons around the size of the window
			float lastButtonXMax = ImGui::GetItemRectMax().x;
			float nextButtonXMax = lastButtonXMax + style.ItemSpacing.x + buttonSize.x; // Expected position if next button was on same line
			if (index + 1 < textureCount && nextButtonXMax < windowMaxX)
				ImGui::SameLine();
			else
				yPos = ImGui::GetItemRectMax().y + style.ItemSpacing.y;
			ImGui::PopID();

			index++;
		}

		// Reverse iterate as we are deleting values
		for (int i = textureViews.size() - 1; i >= 0; i--)
		{
			textureViews[i]->render(i);
			if (!textureViews[i]->shouldBeOpen)
			{
				delete textureViews[i];
				textureViews.erase(textureViews.begin() + i);
			}
		}
	}

	// Is ran inside of a child window
	void _imGuiDisplayMaterialAssetList()
	{
		const std::map<std::string, DataCount<Material>>& dataMap = _materialRM->getDataMap();
		if (dataMap.empty())
		{
			ImGui::TextDisabled("No Materials Loaded...");
			return;
		}

		for (typename std::map<std::string, DataCount<Material>>::const_iterator it = dataMap.begin(); it != dataMap.end(); it++)
		{
			bool isOpen = ImGui::BeginCollapsingHeaderEx((it->first + "##MaterialPreview").c_str(), it->first.c_str());
			if (isOpen)
			{
				// Display material settings, the stuff that won't change
				ImGui::SeparatorText("Material Settings");
				ImGui::Text("Material ID: %s", it->first.c_str());

				const char* shaderName = lost::_getShaderID(it->second.data->getShader());
				ImGui::Text("Shader:");
				ImGui::SameLine();
				if (shaderName != nullptr)
					ImGui::Text(shaderName);
				else
					ImGui::TextDisabled("In-built");

				// Display material properties, like culling settings
				ImGui::SeparatorText("Material Textures");
#pragma region MaterialTextures

				ImGui::Text("Texture Inputs:");
				ImGui::SameLine();
				ImGui::TextDisabled("(?)");
				ImGui::SetItemTooltip("In alphabetical order (UTF-8, lowest to highest)");
				// Loop over the texture slots of the shader
				ImVec2 hoverToolTipSize = { 300.0f, 300.0f };

				const std::map<std::string, unsigned int>& shaderTextureNameMap = it->second.data->getShader()->getTextureNameMap();
				for (typename std::map<std::string, unsigned int>::const_iterator shaderIt = shaderTextureNameMap.begin(); shaderIt != shaderTextureNameMap.end(); shaderIt++)
				{
					ImGui::BulletText("(%i) %s:", shaderIt->second, shaderIt->first.c_str());
					ImGui::SameLine();
					const char* textureID = lost::_getTextureID(it->second.data->getTexture(shaderIt->first.c_str()));
					if (textureID != nullptr)
					{
						ImGui::TextColored(ImColor(135, 191, 255, 255), textureID);
						if (ImGui::BeginItemTooltip())
						{
							ImGui::Image((ImTextureID)(intptr_t)(it->second.data->getTexture(shaderIt->first.c_str())->getTexture()), hoverToolTipSize);
							ImGui::EndTooltip();
						}
					}
					else
					{
						// Check if the image used is nullptr, meaning it doesn't exist at all
						if (it->second.data->getTexture(shaderIt->first.c_str()) == nullptr)
						{
							ImGui::TextColored(ImColor(80, 107, 138, 255), "(null)");
							ImGui::SetItemTooltip("This texture slot is empty, this may cause issues");
						}
						else
						{
							ImGui::TextColored(ImColor(80, 107, 138, 255), "(unknown)");
							ImGui::SetItemTooltip("This texture exists, but is not in a resource manager and couldn't be found\n\nIf this material was loaded from a .mtl file then this just means that\nthere was no texture needed or included");
						}
					}
				}
#pragma endregion

				// Display material uniforms
				ImGui::SeparatorText("Material Uniforms");
#pragma region MaterialUniforms

				const std::vector<lost::MaterialUniform>& materialUniformList = it->second.data->getMaterialUniforms();
				if (!materialUniformList.empty()) // Check if the material has any set uniforms
				{
					for (const lost::MaterialUniform& uniform : materialUniformList)
					{
						ImGui::BulletText("%s:", uniform.uniformID.c_str());
						ImGui::SameLine();
						ImGui::PushID(uniform.uniformID.c_str());
						switch (uniform.type)
						{
						case LOST_TYPE_FLOAT:
							ImGui::DragFloat("##set", (float*)uniform.data, 0.1f);
							break;
						case LOST_TYPE_VEC2:
							ImGui::DragFloat2("##set", (float*)uniform.data, 0.1f);
							break;
						case LOST_TYPE_VEC3:
							ImGui::DragFloat3("##set", (float*)uniform.data, 0.1f);
							break;
						case LOST_TYPE_VEC4:
							ImGui::DragFloat4("##set", (float*)uniform.data, 0.1f);
							break;
						case LOST_TYPE_INT:
							ImGui::DragInt("##set", (int*)uniform.data);
							break;
						case LOST_TYPE_IVEC2:
							ImGui::DragInt2("##set", (int*)uniform.data);
							break;
						case LOST_TYPE_IVEC3:
							ImGui::DragInt3("##set", (int*)uniform.data);
							break;
						case LOST_TYPE_IVEC4:
							ImGui::DragInt4("##set", (int*)uniform.data);
							break;
						case LOST_TYPE_UINT:
							ImGui::DragInt("##set", (int*)(uniform.data), 1.0f, 0);
							break;
						case LOST_TYPE_UVEC2:
							ImGui::DragInt2("##set", (int*)(uniform.data), 1.0f, 0);
							break;
						case LOST_TYPE_UVEC3:
							ImGui::DragInt3("##set", (int*)(uniform.data), 1.0f, 0);
							break;
						case LOST_TYPE_UVEC4:
							ImGui::DragInt4("##set", (int*)(uniform.data), 1.0f, 0);
							break;
						//case LOST_DOUBLE:
						//	ImGui::DragFloat("##set", (float*)uniform.data, 0.1f);
						//	break;
						//case LOST_DVEC2:
						//	ImGui::DragFloat2("##set", (float*)uniform.data, 0.1f);
						//	break;
						//case LOST_DVEC3:
						//	ImGui::DragFloat3("##set", (float*)uniform.data, 0.1f);
						//	break;
						//case LOST_DVEC4:
						//	ImGui::DragFloat4("##set", (float*)uniform.data, 0.1f);
						//	break;
						case LOST_TYPE_BOOL:
							ImGui::Checkbox("##setA", (bool*)uniform.data);
							break;
						case LOST_TYPE_BVEC2:
							ImGui::Checkbox("##setA", (bool*)uniform.data); ImGui::SameLine();
							ImGui::Checkbox("##setB", (bool*)uniform.data + 1 * sizeof(float) / sizeof(bool));
							break;
						case LOST_TYPE_BVEC3:
							ImGui::Checkbox("##setA", (bool*)uniform.data); ImGui::SameLine();
							ImGui::Checkbox("##setB", (bool*)uniform.data + 1 * sizeof(float) / sizeof(bool)); ImGui::SameLine();
							ImGui::Checkbox("##setC", (bool*)uniform.data + 2 * sizeof(float) / sizeof(bool));
							break;
						case LOST_TYPE_BVEC4:
							ImGui::Checkbox("##setA", (bool*)uniform.data); ImGui::SameLine();
							ImGui::Checkbox("##setB", (bool*)uniform.data + 1 * sizeof(float) / sizeof(bool)); ImGui::SameLine();
							ImGui::Checkbox("##setC", (bool*)uniform.data + 2 * sizeof(float) / sizeof(bool)); ImGui::SameLine();
							ImGui::Checkbox("##setD", (bool*)uniform.data + 3 * sizeof(float) / sizeof(bool));
							break;
						default:
							ImGui::TextDisabled("Unable to set this value");
							break;
						}
						ImGui::PopID();

						ImGui::SameLine();
						ImGui::TextDisabled("(?)");
						if (ImGui::BeginItemTooltip())
						{
							ImGui::BulletText("Name: %s", uniform.uniformID.c_str());
							ImGui::BulletText("Location:");
							ImGui::SameLine();
							if (uniform.location != -1)
								ImGui::Text("%i", uniform.location);
							else
							{
								ImGui::TextDisabled("Not in shader...");
								ImGui::SetItemTooltip("The uniform was either not in the shader or optimized out of it");
							}

							ImGui::BulletText("Type:");
							ImGui::SameLine();
							if (uniform.type != LOST_TYPE_STRUCT)
								ImGui::TextColored(ImColor(135, 191, 255, 255), _UniformIDName.at(uniform.type).c_str());
							else
							{
								ImGui::TextColored(ImColor(237, 93, 83, 255), "Struct");
								ImGui::SetItemTooltip("The uniform type was either a struct or unknown");
							}

							ImGui::EndTooltip();
						}
					}
				}
				else
				{
					ImGui::TextDisabled("Material has no set uniforms");
				}
#pragma endregion

				// Display material properties, like culling settings
				ImGui::SeparatorText("Material Properties");

				// Display cull mode
				ImGui::Text("Cull Mode:");
#pragma region CullMode
				//ImGui::SameLine(ImGui::GetContentRegionAvail().x - ImGui::CalcItemWidth() - ImGui::CalcTextSize("(?)").x);
				ImGui::SameLine();
				{
					int item_current = 1;
					switch (it->second.data->getFaceCullMode())
					{
					case LOST_CULL_NONE:
						item_current = 0;
						break;
					case LOST_CULL_FRONT:
						item_current = 1;
						break;
					case LOST_CULL_BACK:
						item_current = 2;
						break;
					case LOST_CULL_FRONT_AND_BACK:
						item_current = 3;
						break;
					default:
						break;
					}
					int item_old = item_current;
					const char* items[] = { "None", "Front", "Back", "Front and back" };
					unsigned int enumVals[] = {
						LOST_CULL_NONE,
						LOST_CULL_FRONT,
						LOST_CULL_BACK,
						LOST_CULL_FRONT_AND_BACK
					};
					ImGui::Combo("##Cull Func", &item_current, items, IM_ARRAYSIZE(items), 4);

					if (item_old != item_current)
						it->second.data->setFaceCullMode(enumVals[item_current]);

					ImGui::SameLine();
					ImGui::TextDisabled("(?)");
					switch (it->second.data->getFaceCullMode())
					{
					case LOST_CULL_AUTO:
						ImGui::SetItemTooltip("This value is reserved for the renderer's \"Cull Override\"");
						break;
					case LOST_CULL_BACK:
						ImGui::SetItemTooltip("Culls the back face of rendered polygons");
						break;
					case LOST_CULL_FRONT:
						ImGui::SetItemTooltip("Culls the front face of rendered polygons");
						break;
					case LOST_CULL_FRONT_AND_BACK:
						ImGui::SetItemTooltip("Culls the both faces of rendered polygons (Doesn't cull lines or points)");
						break;
					case LOST_CULL_NONE:
						ImGui::SetItemTooltip("Doesn't cull anything");
						break;
					default:
						ImGui::SetItemTooltip("The value set for the cull mode is unknown");
						break;
					}
				}
#pragma endregion

				// Display depth test function
				ImGui::Text("Depth Test Function:");
#pragma region DepthTestFunction
				ImGui::SameLine();
				{
					int item_current = 1;
					switch (it->second.data->getDepthTestFunc())
					{
					case LOST_DEPTH_TEST_NEVER:
						item_current = 0;
						break;
					case LOST_DEPTH_TEST_LESS:
						item_current = 1;
						break;
					case LOST_DEPTH_TEST_EQUAL:
						item_current = 2;
						break;
					case LOST_DEPTH_TEST_LEQUAL:
						item_current = 3;
						break;
					case LOST_DEPTH_TEST_GREATER:
						item_current = 4;
						break;
					case LOST_DEPTH_TEST_NOTEQUAL:
						item_current = 5;
						break;
					case LOST_DEPTH_TEST_GEQUAL:
						item_current = 6;
						break;
					case LOST_DEPTH_TEST_ALWAYS:
						item_current = 7;
						break;
					default:
						break;
					}
					int item_old = item_current;
					const char* items[] = { "Never", "Less than", "Equal", "Less than or equal", "Greater than", "Not equal", "Greater than or equal", "Always" };
					unsigned int enumVals[] = {
						LOST_DEPTH_TEST_NEVER,
						LOST_DEPTH_TEST_LESS,
						LOST_DEPTH_TEST_EQUAL,
						LOST_DEPTH_TEST_LEQUAL,
						LOST_DEPTH_TEST_GREATER,
						LOST_DEPTH_TEST_NOTEQUAL,
						LOST_DEPTH_TEST_GEQUAL,
						LOST_DEPTH_TEST_ALWAYS
					};
					ImGui::Combo("##Depth Test Func", &item_current, items, IM_ARRAYSIZE(items), 4);

					if (item_old != item_current)
						it->second.data->setDepthTestFunc(enumVals[item_current]);

					ImGui::SameLine();
					ImGui::TextDisabled("(?)");
					switch (it->second.data->getDepthTestFunc())
					{
					case LOST_DEPTH_TEST_LEQUAL:
						ImGui::SetItemTooltip("Only renders the pixel if the depth is less than or equal to the depth buffer");
						break;
					case LOST_DEPTH_TEST_LESS:
						ImGui::SetItemTooltip("Only renders the pixel if the depth is less than the depth buffer");
						break;
					case LOST_DEPTH_TEST_GEQUAL:
						ImGui::SetItemTooltip("Only renders the pixel if the depth is greater than or equal to the depth buffer");
						break;
					case LOST_DEPTH_TEST_GREATER:
						ImGui::SetItemTooltip("Only renders the pixel if the depth is greater than the depth buffer");
						break;
					case LOST_DEPTH_TEST_NEVER:
						ImGui::SetItemTooltip("Never renders the pixel");
						break;
					case LOST_DEPTH_TEST_ALWAYS:
						// [!] TODO: Figure out if this batching toggle should instead be tied to the ZSort setting in the material
						ImGui::SetItemTooltip("Always renders the pixel, disables batching to preserve order");
						break;
					case LOST_DEPTH_TEST_AUTO:
						ImGui::SetItemTooltip("Should not be set in a material, this is reserved for the renderer");
						break;
					case LOST_DEPTH_TEST_EQUAL:
						ImGui::SetItemTooltip("Only renders the pixel if the depth is equal to the depth buffer");
						break;
					case LOST_DEPTH_TEST_NOTEQUAL:
						ImGui::SetItemTooltip("Only renders the pixel if the depth is not equal to the depth buffer");
						break;
					default:
						ImGui::SetItemTooltip("The depth test function value is unknown");
						break;
					}
				}
#pragma endregion

				// Depth test enabled?
				ImGui::Text("Depth Write:");
#pragma region DepthWrite
				ImGui::SameLine();

				// Toggle box for depth write
				bool depthWrite = it->second.data->getDepthWrite();
				ImGui::Checkbox("##depthWrite", &depthWrite);
				if (depthWrite != it->second.data->getDepthWrite())
					it->second.data->setDepthWrite(depthWrite);
				ImGui::SameLine();

				if (depthWrite)
				{
					ImGui::TextColored(ImColor(135, 191, 255, 255), "Enabled");
					ImGui::SetItemTooltip("This material will write to the depth buffer");
				}
				else
				{
					ImGui::TextColored(ImColor(80, 107, 138, 255), "Disabled");
					ImGui::SetItemTooltip("This material will not write to the depth buffer");
				}
#pragma endregion

				// Queue level
				ImGui::Text("Queue Level:");
				ImGui::SameLine();

				int queueLevel = it->second.data->getQueueLevel();
				ImGui::DragInt("##queueSet", &queueLevel);
				if (it->second.data->getQueueLevel() != queueLevel)
					it->second.data->setQueueLevel(queueLevel);

				// ZSort Mode
				// [!] TODO: Add ZSort modes
				ImGui::Text("ZSort Mode:");
#pragma region ZSort
				ImGui::SameLine();
				{
					int item_current = 1;
					switch (it->second.data->getZSortMode())
					{
					case LOST_ZSORT_NORMAL:
						item_current = 0;
						break;
					case LOST_ZSORT_DEPTH:
						item_current = 1;
						break;
					case LOST_ZSORT_NONE:
						item_current = 2;
						break;
					default:
						break;
					}
					int item_old = item_current;
					const char* items[] = { "Normal", "Depth", "None" };
					unsigned int enumVals[] = {
						LOST_ZSORT_NORMAL,
						LOST_ZSORT_DEPTH,
						LOST_ZSORT_NONE
					};
					ImGui::Combo("##ZSort Func", &item_current, items, IM_ARRAYSIZE(items), 4);

					if (item_old != item_current)
						it->second.data->setZSortMode(enumVals[item_current]);

					ImGui::SameLine();
					ImGui::TextDisabled("(?)");
					switch (it->second.data->getZSortMode())
					{
					case LOST_ZSORT_NORMAL:
						ImGui::SetItemTooltip("Sorts into the most optimal order when rendering\nDoes not preserve the order things are rendered or allow for transparency");
						break;
					case LOST_ZSORT_DEPTH:
						ImGui::SetItemTooltip("Sorts by depth, this allows for transparency but is less optimal");
						break;
					case LOST_ZSORT_NONE:
						ImGui::SetItemTooltip("Doesn't sort at all, preserving the order things are rendered");
						break;
					default:
						ImGui::SetItemTooltip("Unknown ZSort mode");
						break;
					}
				}
#pragma endregion

			}
			ImGui::EndCollapsingHeaderEx(isOpen);
		}

	}

	void _imGuiDisplayMeshAssetList()
	{
		const std::map<std::string, DataCount<Mesh>>& dataMap = _meshRM->getDataMap();
		if (dataMap.empty())
		{
			ImGui::TextDisabled("No Meshes Loaded...");
			return;
		}

		for (typename std::map<std::string, DataCount<Mesh>>::const_iterator it = dataMap.begin(); it != dataMap.end(); it++)
		{
			bool isOpen = ImGui::BeginCollapsingHeaderEx((it->first + "##MeshPreview").c_str(), it->first.c_str());
			if (isOpen)
			{
				CompiledMeshData* mesh = (CompiledMeshData*)(it->second.data);

				// [!] TODO: Refactor meshes, they need to have their own VBO or
				// [!]       a shared VBO that is spread across every loaded mesh
				// [!]       storing an index for where to find the mesh in the
				// [!]       list, this makes unloading meshes hard but saves on
				// [!]       data transfers and API Calls

				ImGui::SeparatorText("Mesh Info");
				ImGui::Text("Verticies:");
				ImGui::SameLine();
				ImGui::TextColored(ImColor(135, 191, 255, 255), "%i", mesh->indexData.size());

				ImGui::Text("Render Mode:");
				ImGui::SameLine();
				switch (mesh->meshRenderMode)
				{
				case LOST_MESH_POINTS:
					ImGui::TextColored(ImColor(135, 191, 255, 255), "Points");
					ImGui::SetItemTooltip("Renders each vertex as a point\n[a], [b], [c] = o  o  o");
					break;
				case LOST_MESH_LINES:
					ImGui::TextColored(ImColor(135, 191, 255, 255), "Lines");
					ImGui::SetItemTooltip("Renders every pair of verticies as a seperate line\n[a, b], [c, d] = o--o  o--o");
					break;
				case LOST_MESH_LINE_LOOP:
					ImGui::TextColored(ImColor(135, 191, 255, 255), "Line loop");
					ImGui::SetItemTooltip("Renders every pair of verticies as a seperate line but joins the first and last verticies given\n[a, b], [c, d] then (d, a) is added by the renderer");
					break;
				case LOST_MESH_LINE_STRIP:
					ImGui::TextColored(ImColor(135, 191, 255, 255), "Line strip");
					ImGui::SetItemTooltip("Renders a line of verticies connecting each one given with no seperation, excluding the first and last vertex\n[a, b, c, d] = o--o--o--o");
					break;
				case LOST_MESH_TRIANGLES:
					ImGui::TextColored(ImColor(135, 191, 255, 255), "Triangles");
					ImGui::SetItemTooltip("Renders a triangle for every three verticies given, this has seperation\n[a, b, c], [d, e, f]");
					break;
				case LOST_MESH_TRIANGLE_STRIP:
					ImGui::TextColored(ImColor(135, 191, 255, 255), "Triangle strip");
					ImGui::SetItemTooltip("Renders a strip of triangles, the first three given form a triangle, then any further vertex added creates a new triangle using the last two as it's base\nEg. Given the vertex list A, B, C, D, E, these triangles would be formed: [A, B, C], [B, C, D], [C, D, E]");
					break;
				case LOST_MESH_TRIANGLE_FAN:
					ImGui::TextColored(ImColor(135, 191, 255, 255), "Triangle fan");
					ImGui::SetItemTooltip("Renders a strip of triangles, the first three given form a triangle, then any further vertex added creates a new triangle using the first vertex given and the last vertex given as it's base\nEg. Given the vertex list A, B, C, D, E, these triangles would be formed: [A, B, C], [A, C, D], [A, D, E]\nThey all share A, the first vertex given, but they use the last vertex given as the second vertex");
					break;
				default:
					break;
				}

				
			}
			ImGui::EndCollapsingHeaderEx(isOpen);
		}
	}

	void _imGuiDisplayShaderAssetList()
	{
		const std::map<std::string, DataCount<Shader>>& dataMap = _shaderRM->getDataMap();
		if (dataMap.empty())
		{
			ImGui::TextDisabled("No Shaders Loaded...");
			return;
		}

		for (typename std::map<std::string, DataCount<Shader>>::const_iterator it = dataMap.begin(); it != dataMap.end(); it++)
		{
			bool isOpen = ImGui::BeginCollapsingHeaderEx((it->first + "##ShaderPreview").c_str(), it->first.c_str());
			if (isOpen)
			{
				ImGui::SeparatorText("Shader Info");

				ImGui::Text("Name:");
				ImGui::SameLine();
				ImGui::TextColored(ImColor(135, 191, 255, 255), it->first.c_str());

				// Get the file location text, if it's nullptr returning it with in-build
				const char* vertDir = it->second.data->getVertexDir();
				vertDir = vertDir == nullptr ? "In-built" : vertDir;
				const char* fragDir = it->second.data->getFragmentDir();
				fragDir = fragDir == nullptr ? "In-built" : fragDir;

				const char* vertSource = it->second.data->getVertexSource();
				vertSource = vertSource == nullptr ? "Unknown source..." : vertSource;
				const char* fragSource = it->second.data->getFragmentSource();
				fragSource = fragSource == nullptr ? "Unknown source..." : fragSource;

				ImGui::Text("Vertex Shader:");
				ImGui::SameLine();
				ImGui::TextColored(ImColor(135, 191, 255, 255), vertDir);
				ImGui::Text("Fragment Shader:");
				ImGui::SameLine();
				ImGui::TextColored(ImColor(135, 191, 255, 255), fragDir);

				if (ImGui::Button("Reload Shader", { ImGui::GetContentRegionAvail().x, 0 }))
					it->second.data->reloadShader();

				ImGui::SeparatorText("Texture Slots");
				// Loop over texture slots in shader
				const std::map<std::string, unsigned int>& textureSlots = it->second.data->getTextureNameMap();
				for (typename std::map<std::string, unsigned int>::const_iterator texIt = textureSlots.begin(); texIt != textureSlots.end(); texIt++)
				{
					ImGui::Bullet();
					ImGui::Text("Slot:");
					ImGui::SameLine();
					ImGui::TextColored(ImColor(135, 191, 255, 255), "%i", texIt->second);
					ImGui::SameLine();
					ImGui::TextColored(ImColor(135, 191, 255, 255), texIt->first.c_str());
				}

				ImGui::SeparatorText("Uniforms");
				// Loop over uniforms in shader
				const std::map<std::string, lost::_Shader::UniformData>& uniforms = it->second.data->getUniformNameMap();

				std::vector<const char*> nameList;
				std::vector<const lost::_Shader::UniformData*> uniformList;
				nameList.reserve(uniforms.size());
				uniformList.reserve(uniforms.size());

				if (!uniforms.empty())
				{
					for (typename std::map<std::string, lost::_Shader::UniformData>::const_iterator uniformIt = uniforms.begin(); uniformIt != uniforms.end(); uniformIt++)
					{
						const lost::_Shader::UniformData& uniform = uniformIt->second;

						bool isOpen = false;
						if (uniformIt->second.location == -1)
						{
							ImGui::BeginDisabled();
							isOpen = ImGui::BeginCollapsingHeaderEx((uniformIt->first + "##UniformPreview").c_str(), ("[x] " + uniformIt->first).c_str());
						}
						else
						{
							isOpen = ImGui::BeginCollapsingHeaderEx((uniformIt->first + "##UniformPreview").c_str(), (uniformIt->first + (uniform.isArray ? "[]" : "")).c_str(), nullptr);
							nameList.push_back(uniformIt->first.c_str());
							uniformList.push_back(&uniform);
						}

						if (isOpen)
						{
							ImGui::Bullet();
							ImGui::Text("Name:");
							ImGui::SameLine();
							ImGui::TextColored(ImColor(135, 191, 255, 255), uniformIt->first.c_str());

							ImGui::Bullet();
							ImGui::Text("Type:");
							ImGui::SameLine();
							ImGui::TextColored(ImColor(135, 191, 255, 255), lost::_UniformIDName[uniform.type].c_str());
							if (uniform.isArray)
							{
								ImGui::SameLine();
								ImGui::TextColored(ImColor(135, 191, 255, 255), "[Array]");
							}

							ImGui::Bullet();
							ImGui::Text("Location:");
							ImGui::SameLine();
							ImGui::TextColored(ImColor(135, 191, 255, 255), "%i", uniform.location);
						}
						ImGui::EndCollapsingHeaderEx(isOpen);

						if (uniformIt->second.location == -1)
						{
							ImGui::EndDisabled();
							ImGui::SetItemTooltip("This uniform wasn't found in the compiled shader\nEither it got optimized out or there was an issue in the compilation");
						}
					}

					// Set uniform value menu
					ImGui::SeparatorText("Set Uniform Value (?)");
					ImGui::SetItemTooltip("Only use this on values that aren't set on code\nThere is no issue with doing this, but the value you put in will most like be overriden immediately and will have no effect");

					// Store the selected value on the uniformSelectors map so it persists
					// One is created per shader
					if (!uniformList.empty())
					{
						int* currentItem = nullptr;
						UniformSelection* selection = nullptr;

						if (uniformSelectors.count(it->first) > 0)
						{
							currentItem = &(uniformSelectors[it->first].selectedUniformIndex);
							selection = &uniformSelectors[it->first];
						}
						else
						{
							uniformSelectors[it->first] = UniformSelection{};
							currentItem = &(uniformSelectors[it->first].selectedUniformIndex);

							selection = &uniformSelectors[it->first];
							selection->selectedUniformIndex = 0;
						}

						if (*currentItem >= uniformList.size())
							*currentItem = 0;

						// Selector
						bool changedUniform = ImGui::Combo("##setUniformVal", currentItem, nameList.data(), nameList.size());
						bool queryShader = changedUniform;

						ImGui::SameLine();
						ImGui::Text("Type:");
						ImGui::SameLine();
						ImGui::TextColored(ImColor(135, 191, 255, 255), lost::_UniformIDName[(*uniformList.at(*currentItem)).type].c_str());

						if ((*uniformList.at(*currentItem)).isArray)
						{
							// Adding onto the type line
							ImGui::SameLine();
							ImGui::TextColored(ImColor(135, 191, 255, 255), "[Array]");

							queryShader = queryShader || ImGui::DragInt("Index", (int*)&selection->offset, 0.05, 0, GL_MAX_UNIFORM_LOCATIONS);
							ImGui::SameLine();
							ImGui::TextDisabled("(?)");
							ImGui::SetItemTooltip("Note: this value is not clamped and may check data that is out of bounds from the array\nAccidentally checking out of bounds does not cause any issues");
						}

						if (queryShader)
						{
							switch ((*uniformList.at(*currentItem)).type)
							{
							case LOST_TYPE_FLOAT:
							case LOST_TYPE_VEC2:
							case LOST_TYPE_VEC3:
							case LOST_TYPE_VEC4:
								glGetUniformfv(it->second.data->getShaderID(), (*uniformList.at(*currentItem)).location + selection->offset, selection->fv);
								break;
							case LOST_TYPE_INT:
							case LOST_TYPE_IVEC2:
							case LOST_TYPE_IVEC3:
							case LOST_TYPE_IVEC4:
								glGetUniformiv(it->second.data->getShaderID(), (*uniformList.at(*currentItem)).location + selection->offset, selection->iv);
								break;
							case LOST_TYPE_UINT:
							case LOST_TYPE_UVEC2:
							case LOST_TYPE_UVEC3:
							case LOST_TYPE_UVEC4:
								glGetUniformuiv(it->second.data->getShaderID(), (*uniformList.at(*currentItem)).location + selection->offset, selection->uiv);
								break;
							//case LOST_DOUBLE:
							//case LOST_DVEC2:
							//case LOST_DVEC3:
							//case LOST_DVEC4:
							//	glGetUniformdv(it->second.data->getShaderID(), (*uniformList.at(*currentItem)).location, selection->dv);
							//	break;
							case LOST_TYPE_BOOL:
							case LOST_TYPE_BVEC2:
							case LOST_TYPE_BVEC3:
							case LOST_TYPE_BVEC4:
								glGetUniformiv(it->second.data->getShaderID(), (*uniformList.at(*currentItem)).location + selection->offset, (int*)selection->bv);
								break;
							default:
								break;
							}
						}

						bool change = false;

						switch ((*uniformList.at(*currentItem)).type)
						{
						case LOST_TYPE_FLOAT:
							change = ImGui::DragFloat("##set", selection->fv, 0.1f);
							break;
						case LOST_TYPE_VEC2:
							change = ImGui::DragFloat2("##set", selection->fv, 0.1f);
							break;
						case LOST_TYPE_VEC3:
							change = ImGui::DragFloat3("##set", selection->fv, 0.1f);
							break;
						case LOST_TYPE_VEC4:
							change = ImGui::DragFloat4("##set", selection->fv, 0.1f);
							break;
						case LOST_TYPE_INT:
							change = ImGui::DragInt("##set", selection->iv);
							break;
						case LOST_TYPE_IVEC2:
							change = ImGui::DragInt2("##set", selection->iv);
							break;
						case LOST_TYPE_IVEC3:
							change = ImGui::DragInt3("##set", selection->iv);
							break;
						case LOST_TYPE_IVEC4:
							change = ImGui::DragInt4("##set", selection->iv);
							break;
						case LOST_TYPE_UINT:
							change = ImGui::DragInt("##set", (int*)(selection->uiv), 1.0f, 0);
							break;
						case LOST_TYPE_UVEC2:
							change = ImGui::DragInt2("##set", (int*)(selection->uiv), 1.0f, 0);
							break;
						case LOST_TYPE_UVEC3:
							change = ImGui::DragInt3("##set", (int*)(selection->uiv), 1.0f, 0);
							break;
						case LOST_TYPE_UVEC4:
							change = ImGui::DragInt4("##set", (int*)(selection->uiv), 1.0f, 0);
							break;
						//case LOST_DOUBLE:
						//	change = ImGui::DragFloat("##set", selection->fv, 0.1f);
						//	break;
						//case LOST_DVEC2:
						//	change = ImGui::DragFloat2("##set", selection->fv, 0.1f);
						//	break;
						//case LOST_DVEC3:
						//	change = ImGui::DragFloat3("##set", selection->fv, 0.1f);
						//	break;
						//case LOST_DVEC4:
						//	change = ImGui::DragFloat4("##set", selection->fv, 0.1f);
						//	break;
						case LOST_TYPE_BOOL:
							change = ImGui::Checkbox("##setA", selection->bv);
							break;
						case LOST_TYPE_BVEC2:
							change = ImGui::Checkbox("##setA", selection->bv); ImGui::SameLine();
							change = change || ImGui::Checkbox("##setB", selection->bv + 1 * sizeof(float) / sizeof(bool));
							break;
						case LOST_TYPE_BVEC3:
							change = ImGui::Checkbox("##setA", selection->bv); ImGui::SameLine();
							change = change || ImGui::Checkbox("##setB", selection->bv + 1 * sizeof(float) / sizeof(bool)); ImGui::SameLine();
							change = change || ImGui::Checkbox("##setC", selection->bv + 2 * sizeof(float) / sizeof(bool));
							break;
						case LOST_TYPE_BVEC4:
							change = ImGui::Checkbox("##setA", selection->bv); ImGui::SameLine();
							change = change || ImGui::Checkbox("##setB", selection->bv + 1 * sizeof(float) / sizeof(bool)); ImGui::SameLine();
							change = change || ImGui::Checkbox("##setC", selection->bv + 2 * sizeof(float) / sizeof(bool)); ImGui::SameLine();
							change = change || ImGui::Checkbox("##setD", selection->bv + 3 * sizeof(float) / sizeof(bool));
							break;
						default:
							ImGui::TextDisabled("Unable to set this value");
							break;
						}

						ImGui::SameLine();
						ImGui::BeginDisabled(selection->liveSet);
						if (ImGui::Button("Set!"))
						{
							it->second.data->setUniform((void*)(selection->fv), (*uniformList.at(*currentItem)).location, (*uniformList.at(*currentItem)).type, 1, selection->offset);
						}
						ImGui::EndDisabled();

						ImGui::SameLine();
						if (changedUniform) // If the uniform was changed turn off live set so that it doesn't override any values
						{
							selection->liveSet = false;
							selection->offset = 0;
						}
						ImGui::Checkbox("Live Set", &selection->liveSet);
						ImGui::SameLine();
						ImGui::TextDisabled("(?)");
						ImGui::SetItemTooltip("Sets the uniform as the setting changes, this setting turns off if you change the selected uniform");
						if (change && selection->liveSet)
						{
							it->second.data->setUniform((void*)(selection->fv), (*uniformList.at(*currentItem)).location, (*uniformList.at(*currentItem)).type, 1, selection->offset);
						}
					}
					else
					{
						ImGui::TextDisabled("No active uniforms in compiled shader");
					}
				}
				else
				{
					ImGui::TextDisabled("No uniforms were found");
				}
			}
			ImGui::EndCollapsingHeaderEx(isOpen);
		}
	}

	void _imGuiDisplayFontAssetList()
	{
		const std::map<std::string, DataCount<Font>>& dataMap = _fontRM->getDataMap();

		if (dataMap.empty())
		{
			ImGui::TextDisabled("No Fonts Loaded...");
			return;
		}

		for (typename std::map<std::string, DataCount<Font>>::const_iterator it = dataMap.begin(); it != dataMap.end(); it++)
		{
			const Font font = it->second.data;

			bool isOpen = ImGui::BeginCollapsingHeaderEx((it->first + "##FontPreview").c_str(), it->first.c_str());
			if (isOpen)
			{
				ImGui::SeparatorText("Font Info");

				ImGui::Text("ID:");
				ImGui::SameLine();
				ImGui::TextColored(ImColor(135, 191, 255, 255), it->first.c_str());

				ImGui::Text("Font Height:");
				ImGui::SameLine();
				ImGui::TextColored(ImColor(135, 191, 255, 255), "%i", font->fontHeight);
				ImGui::SameLine();
				ImGui::TextDisabled("(?)");
				ImGui::SetItemTooltip("This is essentially the quality of the font\nThe higher this number the larger the font was rendered onto the bitmap");

				const char* textureID = lost::_getTextureID(font->fontTexture);
				ImVec2 hoverToolTipSize = { 300.0f, 300.0f };

				ImGui::Text("Texture:");
				ImGui::SameLine();
				ImGui::TextColored(ImColor(135, 191, 255, 255), textureID);
				if (ImGui::BeginItemTooltip())
				{
					ImGui::Image((ImTextureID)(intptr_t)(font->fontTexture->getTexture()), hoverToolTipSize);
					ImGui::EndTooltip();
				}
			}
			ImGui::EndCollapsingHeaderEx(isOpen);
		}
	}

	void _imGuiDisplayPostProcessingShaderAssetList()
	{
		const std::map<std::string, DataCount<PostProcessingShader>>& dataMap = _postProcessingShaderRM->getDataMap();

		if (dataMap.empty())
		{
			ImGui::TextDisabled("No Post-processing Shaders Loaded...");
			return;
		}

		for (typename std::map<std::string, DataCount<PostProcessingShader>>::const_iterator it = dataMap.begin(); it != dataMap.end(); it++)
		{
			bool isOpen = ImGui::BeginCollapsingHeaderEx((it->first + "##PostProcessingShaderPreview").c_str(), it->first.c_str());
			if (isOpen)
			{
				ImGui::SeparatorText("Post-processing Shader Info");
			}
			ImGui::EndCollapsingHeaderEx(isOpen);
		}
	}

	void _imGuiDisplayLogList()
	{

		if (LOST_LOG_QUEUE_SIZE > 0) // Check if there is a log queue
		{
			const std::vector<_Log>& logList = lost::_getLogList();

			float offset = 0;
			ImVec2 cursorPos = ImGui::GetCursorScreenPos();

			ImDrawList* drawList = ImGui::GetWindowDrawList();
			ImGuiStyle& style = ImGui::GetStyle();

			for (const _Log& log : logList)
			{

				const char* prefix = "";

				ImColor textColor;
				switch (log.level)
				{
				case LOST_LOG_NONE:
					textColor = { 200, 200, 200 };
					break;
				case LOST_LOG_SUCCESS:
					textColor = { 50, 255, 75 };
					prefix = "[ Success ] ";
					break;
				case LOST_LOG_INFO:
					textColor = { 100, 150, 255 };
					prefix = "[  Info.  ] ";
					break;
				case LOST_LOG_WARNING:
				case LOST_LOG_WARNING_NO_NOTE:
					textColor = { 255, 255, 50 };
					prefix = "[ Warning ] ";
					break;
				case LOST_LOG_ERROR:
					textColor = { 255, 100, 50 };
					prefix = "[  Error  ] ";
					break;
				default: // We can skip FATAL as that crashes the program
					break;
				}

				drawList->AddText(cursorPos, textColor, (prefix + log.logText).c_str());

				ImVec2 textSize = ImGui::CalcTextSize((prefix + log.logText).c_str());
				cursorPos.y += textSize.y + style.ItemSpacing.y;

				if (ImGui::GetCursorPosX() < textSize.x + 2.0f * style.FramePadding.x)
					ImGui::SetCursorPosX(textSize.x + 2.0f * style.FramePadding.x);
				ImGui::SetCursorPosY(ImGui::GetCursorPosY() + textSize.y + style.ItemSpacing.y);
			}
		}
		else
		{
			const char* errorName = "The log queue has been disabled";

			ImVec2 center = { ImGui::GetContentRegionAvail().x / 2.0f + ImGui::GetCursorPos().x, ImGui::GetContentRegionAvail().y / 2.0f + ImGui::GetCursorPos().y };
			ImVec2 textSize = ImGui::CalcTextSize(errorName);

			ImGui::SetCursorPos({ center.x - textSize.x / 2.0f, center.y - textSize.y / 2.0f });
			ImGui::Text(errorName);
		}
	}

	void _imGuiDisplaySoundList()
	{
		ImGui::SeparatorText("Sounds (Loaded onto RAM)");

		const std::map<std::string, DataCount<Sound>>& dataMap = _soundRM->getDataMap();

		if (dataMap.empty())
		{
			ImGui::TextDisabled("No Sounds Loaded...");
		}

		for (typename std::map<std::string, DataCount<Sound>>::const_iterator it = dataMap.begin(); it != dataMap.end(); it++)
		{
			const Sound sound = it->second.data;

			bool isOpen = ImGui::BeginCollapsingHeaderEx((it->first + "##SoundPreview").c_str(), it->first.c_str());
			if (isOpen)
			{
				ImGui::SeparatorText("Sound Info");

				ImGui::Text("ID:");
				ImGui::SameLine();
				ImGui::TextColored(ImColor(135, 191, 255, 255), it->first.c_str());

				// Playtime in seconds
				float playTime = (float)sound->_getSoundInfo().sampleCount / (float)sound->_getSoundInfo().sampleRate;

				int seconds = int(fmodf(playTime, 60));
				int minutes = int(playTime / 60.0f);

				ImGui::Text("Playtime:");
				ImGui::SameLine();
				ImGui::TextColored(ImColor(135, 191, 255, 255), (seconds < 10 ? "%i:0%i" : "%i:%i"), minutes, seconds);

				ImGui::SeparatorText("Detailed Sound Info");

				ImGui::Text("Functional:");
				ImGui::SameLine();
				ImGui::TextColored(ImColor(135, 191, 255, 255), sound->isFunctional() ? "Yes" : "No");

				ImGui::Text("Sample Rate:");
				ImGui::SameLine();
				ImGui::TextColored(ImColor(135, 191, 255, 255), "%i", sound->_getSoundInfo().sampleRate);

				ImGui::Text("Sample Count:");
				ImGui::SameLine();
				ImGui::TextColored(ImColor(135, 191, 255, 255), "%i", sound->_getSoundInfo().sampleCount);

				ImGui::Text("Channels:");
				ImGui::SameLine();
				ImGui::TextColored(ImColor(135, 191, 255, 255), "%i", sound->_getSoundInfo().channelCount);

				ImGui::Text("Format:");
				ImGui::SameLine();
				ImGui::TextColored(ImColor(135, 191, 255, 255), "%i Bit PCM", sound->_getSoundInfo().format << 3);
			}
			ImGui::EndCollapsingHeaderEx(isOpen);
		}

		ImGui::SeparatorText("Sound Streams");

		const std::map<std::string, DataCount<SoundStream>>& streamDataMap = _streamRM->getDataMap();

		if (streamDataMap.empty())
		{
			ImGui::TextDisabled("No Sound Streams Loaded...");
		}

		for (typename std::map<std::string, DataCount<SoundStream>>::const_iterator it = streamDataMap.begin(); it != streamDataMap.end(); it++)
		{
			const SoundStream stream = it->second.data;

			bool isOpen = ImGui::BeginCollapsingHeaderEx((it->first + "##SoundPreview").c_str(), it->first.c_str());
			if (isOpen)
			{
				ImGui::SeparatorText("Sound Info");

				ImGui::Text("ID:");
				ImGui::SameLine();
				ImGui::TextColored(ImColor(135, 191, 255, 255), it->first.c_str());

				// Playtime in seconds
				float playTime = (float)stream->_getSoundInfo().sampleCount / (float)stream->_getSoundInfo().sampleRate;

				int seconds = int(fmodf(playTime, 60));
				int minutes = int(playTime / 60.0f);

				ImGui::Text("Playtime:");
				ImGui::SameLine();
				ImGui::TextColored(ImColor(135, 191, 255, 255), (seconds < 10 ? "%i:0%i" : "%i:%i"), minutes, seconds);

				ImGui::SeparatorText("Detailed Sound Info");

				ImGui::Text("Functional:");
				ImGui::SameLine();
				ImGui::TextColored(ImColor(135, 191, 255, 255), stream->isFunctional() ? "Yes" : "No");

				ImGui::Text("Sample Rate:");
				ImGui::SameLine();
				ImGui::TextColored(ImColor(135, 191, 255, 255), "%i", stream->_getSoundInfo().sampleRate);

				ImGui::Text("Sample Count:");
				ImGui::SameLine();
				ImGui::TextColored(ImColor(135, 191, 255, 255), "%i", stream->_getSoundInfo().sampleCount);

				ImGui::Text("Channels:");
				ImGui::SameLine();
				ImGui::TextColored(ImColor(135, 191, 255, 255), "%i", stream->_getSoundInfo().channelCount);

				ImGui::Text("Format:");
				ImGui::SameLine();
				ImGui::TextColored(ImColor(135, 191, 255, 255), "%i Bit PCM", stream->_getSoundInfo().format << 3);
			}
			ImGui::EndCollapsingHeaderEx(isOpen);
		}

	}

	void imGuiDisplayProgramInfo()
	{
		ImGuiWindowFlags flags = 0;
		ImGui::Begin("Lost Info");

		// Make a tab bar
		ImGui::BeginTabBar("Tabs");

		if (ImGui::BeginTabItem("Info"))
		{
			ImGui::SeparatorText("Engine Info");

			int frameRate = lost::getFrameRate();

			ImVec4 frameRateColor = { 1.0f, 1.0f, 1.0f, 1.0f };
			if (frameRate < 15)
				frameRateColor = { 0.5f, 0.0f,  0.0f, 1.0f };
			else if (frameRate < 30)
				frameRateColor = { 1.0f, 0.0f,  0.0f, 1.0f };
			else if (frameRate < 45)
				frameRateColor = { 1.0f, 0.5f,  0.0f, 1.0f };
			else if (frameRate < 50)
				frameRateColor = { 0.5f, 0.75f, 0.0f, 1.0f };
			else if (frameRate < 60)
				frameRateColor = { 0.0f, 1.0f,  0.0f, 1.0f };
			else
				frameRateColor = { 0.5f, 1.0f,  0.5f, 1.0f };

			ImGui::Text("FPS:");
			ImGui::SameLine();
			ImGui::TextColored(frameRateColor, "%i", frameRate);

			bool isOpen = ImGui::BeginCollapsingHeaderEx("##LOST_FrameRateHistoryWindow", "View Frame-time History (Only active when open)");
			if (isOpen)
			{
				frameHistory.addFrameTime(lost::getDeltaTime());
				frameHistory._imGuiDisplayFrameTimeInfo();
			}
			ImGui::EndCollapsingHeaderEx(isOpen);

			isOpen = ImGui::BeginCollapsingHeaderEx("Logs##LOST_logMenu", "View Logs");
			if (isOpen)
			{
				ImDrawList* drawList = ImGui::GetWindowDrawList();
				ImGuiStyle& style = ImGui::GetStyle();

				int borderRound = 8;
				int roundingCorners = ImDrawFlags_RoundCornersLeft;
				int logHeight = 500;

				ImColor fillColor = { 4, 4, 7, 255 };
				ImColor borderColor = { 0x40, 0x40, 0x49, 255 };

				ImVec2 cursorPos = ImGui::GetCursorPos();
				ImVec2 min = ImGui::GetCursorScreenPos();
				ImVec2 max = { ImGui::GetContentRegionAvail().x + ImGui::GetCursorScreenPos().x, ImGui::GetCursorScreenPos().y + logHeight };

				drawList->AddRectFilled(min, max, fillColor,   borderRound, roundingCorners);
				drawList->AddRect(      min, max, borderColor, borderRound, roundingCorners);

				ImGui::SetCursorPos({ cursorPos.x + 1, cursorPos.y + 1 });
				ImGui::BeginChild("##LOST_logMenu", ImVec2{ ImGui::GetContentRegionAvail().x - 1.0f, (float)logHeight - 2.0f}, ImGuiChildFlags_None | ImGuiChildFlags_AlwaysUseWindowPadding, ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_NoBackground);
				_imGuiDisplayLogList();
				ImGui::EndChild();

				ImGui::SetCursorPos({ cursorPos.x, cursorPos.y + logHeight + style.ItemSpacing.y });
			}
			ImGui::EndCollapsingHeaderEx(isOpen);
			ImGui::EndTabItem();
		}

		if (ImGui::BeginTabItem("Graphics"))
		{
			ImGui::SeparatorText("Renderer Info");

			const lost::LostState& state = lost::getLostState();
			ImGui::Text("Renderer:");
			ImGui::SameLine();
			if (state.rendererMode == LOST_RENDER_3D)
				ImGui::Text("3D");
			else
				ImGui::Text("2D");

			ImGui::Text("Available Output Passes:");
			for (int i = 0; i < state.currentBuffers.size(); i++)
			{
				bool isOpen = ImGui::BeginCollapsingHeaderEx((state.currentBuffers[i].name + "##OutputBuffer").c_str(), state.currentBuffers[i].name.c_str());
				if (isOpen)
				{
					ImGui::BulletText("Location: %i", i);
					ImGui::BulletText("Format: %s", lost::formatToName(state.currentBuffers[i].format));
					ImGui::BulletText("Clear Color:");
					ImGui::SameLine();
					ImVec4 clearColor = ImVec4(state.currentBuffers[i].defaultColor.x, state.currentBuffers[i].defaultColor.y, state.currentBuffers[i].defaultColor.z, state.currentBuffers[i].defaultColor.w);
					ImGui::ColorEdit4("##ColorPicker", &clearColor.x);
					if (clearColor.x != state.currentBuffers[i].defaultColor.x || clearColor.y != state.currentBuffers[i].defaultColor.y || clearColor.z != state.currentBuffers[i].defaultColor.z || clearColor.w != state.currentBuffers[i].defaultColor.w)
						lost::setClearColor(i, { clearColor.x, clearColor.y, clearColor.z, clearColor.w });
				}
				ImGui::EndCollapsingHeaderEx(isOpen);
			}

			const std::vector<Window>& windows = lost::getWindows();

			ImGui::SeparatorText("Windows");
			ImGui::Text("Active Windows:");
			for (int i = 0; i < windows.size(); i++)
			{
				Window window = windows[i];
				ImGui::PushID(i);

				bool isOpen = ImGui::BeginCollapsingHeaderEx((std::to_string(i) + "windowTab##WindowTabPreview").c_str(), (std::string("Window ") + std::to_string(i)).c_str());

				if (isOpen)
				{
					if (i == 0)
						ImGui::TextDisabled("ImGui is bound to this one!");

					std::string windowTitle = window->title;

					char buffer[50];
					windowTitle.copy(buffer, min(48, windowTitle.size()));
					buffer[min(49, windowTitle.size())] = '\0';

					ImGui::Bullet();
					ImGui::Text("Bounds: %iw %ih", window->width, window->height);

					//ImGui::Spacing();

					ImGui::Bullet();
					if (ImGui::InputText("Title", buffer, 50, ImGuiInputTextFlags_EnterReturnsTrue))
						lost::setWindowTitle(buffer, window);
					
					bool vsyncToggle = window->vSyncEnabled;
					ImGui::Bullet();
					ImGui::Checkbox("Uses VSync?", &vsyncToggle);
					if (vsyncToggle != window->vSyncEnabled)
						lost::useVSync(vsyncToggle, window);

					ImGui::Bullet();
					if (ImGui::Button("Close Window", { 300, 0 }))
						lost::closeWindow(window);

					ImGui::Bullet();
					if (window->_isFullScreen)
					{
						if (ImGui::Button("Unfullscreen Window", { 300, 0 }))
							lost::makeWindowWindowed(500, 500, window);
					}
					else
					{
						if (ImGui::Button("Fullscreen Window", { 300, 0 }))
							lost::makeWindowFullscreen(true, window);
					}

					ImGui::SeparatorText("Render Passes");
					for (int j = 0; j < state.currentBuffers.size(); j++)
					{
						bool isOpen = ImGui::BeginCollapsingHeaderEx((state.currentBuffers[j].name + std::to_string(i) + "##OutputBuffer").c_str(), state.currentBuffers[j].name.c_str());
						if (isOpen)
						{
							float width = ImGui::GetContentRegionAvail().x;
							float ratio = (float)getHeight(getWindow(i)) / (float)getWidth(getWindow(i));
							ImGui::Image((ImTextureID)(getRenderTexture(j, i)), { width, width * ratio }, { 0.0, 1.0 }, { 1.0, 0.0 });
						}
						ImGui::EndCollapsingHeaderEx(isOpen);
					}

					// Display depth buffer
					bool depthIsOpen = ImGui::BeginCollapsingHeaderEx((std::to_string(i) + "DepthBuffer##OutputBuffer").c_str(), "Depth Buffer");
					if (depthIsOpen)
					{
						float width = ImGui::GetContentRegionAvail().x;
						float ratio = (float)getHeight(getWindow(i)) / (float)getWidth(getWindow(i));
						ImGui::Image((ImTextureID)(getDepthTexture(i)), { width, width * ratio }, { 0.0, 1.0 }, { 1.0, 0.0 });
					}
					ImGui::EndCollapsingHeaderEx(depthIsOpen);

				}

				ImGui::EndCollapsingHeaderEx(isOpen);
				ImGui::PopID();
			}

			ImGui::EndTabItem();
		}

		if (ImGui::BeginTabItem("Assets"))
		{
			ImGui::SeparatorText("Textures");
			ImGui::Text("Currently loaded %i texture(s)...", _textureRM->getValueCount());

			bool isOpen = ImGui::BeginCollapsingHeaderEx("##textureAssetList", "View Textures");
			if (isOpen)
				_imGuiDisplayTextureAssetList();
			ImGui::EndCollapsingHeaderEx(isOpen);

			ImGui::SeparatorText("Materials");
			ImGui::Text("Currently loaded %i material(s)...", _materialRM->getValueCount());
			isOpen = ImGui::BeginCollapsingHeaderEx("##materialAssetList", "View Materials");
			if (isOpen)
				_imGuiDisplayMaterialAssetList();
			ImGui::EndCollapsingHeaderEx(isOpen);

			ImGui::SeparatorText("Meshes");
			ImGui::Text("Currently loaded %i mesh(es)...", _meshRM->getValueCount());
			isOpen = ImGui::BeginCollapsingHeaderEx("##meshAssetList", "View Meshes");
			if (isOpen)
				_imGuiDisplayMeshAssetList();
			ImGui::EndCollapsingHeaderEx(isOpen);

			ImGui::SeparatorText("Shaders");
			ImGui::Text("Currently loaded %i shader(s)...", _shaderRM->getValueCount());
			isOpen = ImGui::BeginCollapsingHeaderEx("##shaderAssetList", "View Shaders");
			if (isOpen)
				_imGuiDisplayShaderAssetList();
			ImGui::EndCollapsingHeaderEx(isOpen);

			ImGui::SeparatorText("Post-processing Shaders");
			ImGui::Text("Currently loaded %i post-processing shader(s)...", _postProcessingShaderRM->getValueCount());
			isOpen = ImGui::BeginCollapsingHeaderEx("##ppShaderAssetList", "View Post-processing shaders");
			if (isOpen)
				_imGuiDisplayPostProcessingShaderAssetList();
			ImGui::EndCollapsingHeaderEx(isOpen);

			ImGui::SeparatorText("Fonts");
			ImGui::Text("Currently loaded %i font(s)...", _fontRM->getValueCount());
			isOpen = ImGui::BeginCollapsingHeaderEx("##fontAssetList", "View Fonts");
			if (isOpen)
				_imGuiDisplayFontAssetList();
			ImGui::EndCollapsingHeaderEx(isOpen);

			ImGui::SeparatorText("Sounds");
			ImGui::Text("Currently loaded %i sound(s) and %i sound stream(s)...", _soundRM->getValueCount(), _streamRM->getValueCount());
			isOpen = ImGui::BeginCollapsingHeaderEx("##soundAssetList", "View Sounds");
			if (isOpen)
				_imGuiDisplaySoundList();
			ImGui::EndCollapsingHeaderEx(isOpen);

			ImGui::EndTabItem();
		}

		ImGui::EndTabBar();
		ImGui::End();

	}

}